/*
 * -----------------------
 * --- DEVICE HANDLER ----
 * -----------------------
 *
 * STOP:  Do NOT PUBLISH the code to GitHub, it is a VIOLATION of the license terms.
 * You are NOT allowed share, distribute, reuse or publicly host (e.g. GITHUB) the code. Refer to the license details on our website.
 *
 */

/* **DISCLAIMER**
* THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
* Without limitation of the foregoing, Contributors/Regents expressly does not warrant that:
* 1. the software will meet your requirements or expectations;
* 2. the software or the software content will be free of bugs, errors, viruses or other defects;
* 3. any results, output, or data provided through or generated by the software will be accurate, up-to-date, complete or reliable;
* 4. the software will be compatible with third party software;
* 5. any errors in the software will be corrected.
* The user assumes all responsibility for selecting the software and for the results obtained from the use of the software. The user shall bear the entire risk as to the quality and the performance of the software.
*/ 

def clientVersion() {
    return "04.00.03"
}

/*
* Copyright RBoy Apps, redistribution or reuse of code or any changes is not allowed without permission
* Works with all Z-Wave Locks including Schlage, Yale, Kiwkset, Monoprice, DanaLock, IDLock, Samsung and August
*
* Change Log
* 2018-2-13 - (v04.00.03) Limit relock patch only for FE599
* 2018-1-23 - (v04.00.02) Workaround for pairing issue causing zwInfo showing model as 0000 causing tiles to go missing
* 2018-1-21 - (v04.00.01) Added fingerprints for Vivint Kwikset locks
* 2018-1-16 - (v04.00.00) Updated to support SmartLock app, pinLength is now codeLength, maxCodes introduced, added support for Samsung locks, fix for Yale commercial/residential audio modes
* 2017-11-7 - (v03.05.01) Fixed audio on/off for Yale (it was inverted, on turned it off and vice verse)
* 2017-10-19 - (v03.05.00) Added support for Danalock V3, added support for one touch locking/lock and leave tile
* 2017-10-18 - (v03.04.03) Update tile layout with ST mobile app release 2.8.0
* 2017-10-9 - (v03.04.02) August lock pro MSR patch, only supports secure commands
* 2017-10-5 - (v03.04.01) August lock pro patch for faulty firmware reporting unknown status
* 2017-10-4 - (v03.04.00) Yale assure lock keypad lock detection
* 2017-9-25 - (v03.03.06) Added more Yale Assure locks
* 2017-9-12 - (v03.03.06) Updated base DTH to sync with ST changes
* 2017-8-15 - (v03.03.06) Added support for August Z-Wave locks
* 2017-6-15 - (v03.03.06) When locks are updated(), refresh the MSR incase the lock has been replaced through ST, correctly report Yale and Danalock RF lock/unlock
* 2017-5-29 - (v03.03.05) Added support for more locks (Yale Assa Abloy) and Yale Bluetooth, updated code to latest Yale specifications
* 2017-5-24 - (v03.03.04) Fixed issue with Schlage keypad lock/unlock being reported as Master Code
* 2017-5-23 - (v03.03.03) Added support for reporting Yale RFID tags/user slots
* 2017-5-23 - (v03.03.02) Added support for FE599 series invalid code detection
* 2017-5-4 - (v03.03.01) Updated color scheme to match ST UX recommendations
* 2017-4-19 - (v.03.02.03) Added more Yale fingerprints for Yale Assure Lock and patch for Yale Master Code reporting (code 0 and code 251)
* 2017-3-13 - (v.3.2.2) Don't show unknown and reset states in the recently logs of device
* 2017-2-25 - (v3.2.2) Added fingerprints and identification for Yale Conexis L1
* 2017-2-3 - (v3.2.1) Fix for IDE some users were facing while installing the device handler
* 2017-1-21 - (v3.2.0) Added support for Yale commercial locks (e.g. nexTouch) and tiles for DPS sensor, tampering and fire/smoke alarm
* 2017-1-2 - (v3.1.3) Added ability to report door state for IDLock and Yale DPS, Motion Sensor (Schlage) and Smoke Detector (IDLock) capabilties also need to be uncommented if required
* 2016-11-2 - Added capability tamper alert and improved tamper detection
* 2016-10-23 - Added ability to check for new code versions, check for Yale duplicate codes and read Schlage pin code lengths and save it in `pinLength`
* 2016-10-21 - Added support for Danalock including RF and Keypad
* 2016-10-6 - Added support for FE469
* 2016-9-6 - Do not report advanced feature status in device stream to avoid confusing users
* 2016-8-27 - Added support for enabling/disabling beeper on Schlage FE5xx/BE3xx locks
* 2016-8-23 - Updated battery icon
* 2016-8-19 - Now unsupported features will show up as blank tiles on the screen
* 2016-8-8 - Fix for working with IDLock locks configuration
* 2016-7-27 - Added support for Yale Keyless Connected YD-01 UK lock, more Kwikset and Schlage models, with generic models for future proof support
* 2016-7-25 - Removed warning for Kiwkset, it does not support remote programming, only reading
* 2016-7-24 - Added support for non secure classes (battery, configuration for some locks like IDLock)
* 2016-7-23 - Added support for IDLock RFID lock and fire sensor
* 2016-7-19 - Harmonized events type reporting using data.type, `outsideLockEvent` is no longer used
* 2016-7-14 - Bugfix for Yale lock using code
* 2016-7-13 - Added support for Yale one touch keypad lock and outsideLockEvent notification
* 2016-7-13 - Added support for Yale alarm notifications, Yale lock codes and Yale specific configuration
* 2016-7-13 - Fixed reporting invalidCode instead of tamper for invalid code entries
* 2016-7-11 - Added more support for external button locking with code and for Yale locks
* 2016-7-10 - Added support for external keypad button locked attribute `outsideLockEvent` and tested with BE469
* 2016-5-11 - Kwikset 916/914/910 share same MSR and fingerprint
* 2016-4-20 - Added DH version in setup page
* 2016-4-8 - Fix for invalidCode not always being reported
* 2016-3-31 - Added fingerprint ID's for BE469, FE599, BE369, Kwiket 914, Yale Keyfree
* 2016-3-22 - Added support for 6th generation of Yale locks
* 2016-3-22 - Changed the icon for the sensivitity
* 2016-3-22 - Standardized coding standard
* 2016-3-21 - Added support for Enabling/Disabling Audio/Beeper for Schlage and Yale locks including commands enableAudio and disableAudio
* 2016-3-15 - Fixed updated function
* 2016-3-14 - Added support for Kiwkset 916 and reporting beeper/buzzer via attribute 'beeper'
* 2016-2-15 - Added identification of generic lock types from Schlage
* 2016-2-14 - Improvement to initial setup to associate lock and get MSR
* 2016-2-10 - Added support for additional Yale lock devices
* 2016-2-7 - Fix Support for Yale lock Vacation Mode (Key Code enable/disable)
* 2016-2-6 - Fixed Yale MSR code check
* 2016-2-6 - Added support for Yale locks AutoLock and Keypad disable
* 2016-2-6 - Fixed refresh on configuration
* 2016-2-3 - Fixed an issue with keypad code enable/disable not working for the BE369
* 2016-2-3 - Support future version of Schlage locks and fix issue with unsupported Schlage locks (now prompts user to report the new locks to developer but still tries to configure it)
* 2016-2-2 - Set alarm and sensitive attributes to empty if not supported
* 2016-2-2 - Fixed alarm status not updating on the tile always, indicate when features are not supported by lock
* 2016-1-27 - Fix for battery UI broken after upgrade to ST iOS 2.0.8 app
* 2016-1-27 - Fixed issue with motion sensor for BE469 showing up as 0 in SHM on fresh installation
* 2016-1-23 - Fixed a bug in getting the MSR for a new lock setup
* 2016-1-19 - Fixed a bug in base code, codeReport notifications were not always sent to the SmartApp
* 2015-12-19 - Updated base code and cleaned up
* 2015-12-9 - Added Dummy commented code for enabling switch capabilities for the lock, uncomment code to enable switch capabilities as requested by users
* 2015-12-3 - Fix for delay/error in initialization not populating the features sometimes
* 2015-11-29 - Tweaked the timeout for the relock notification for non motorized deadbolts to 3 seconds
* 2015-11-29 - Added fix for non motorized deadbolt locks like FE599 not reporting locked after user unlocks the door using a code and it relocks automatically
* 2015-11-21 - Readded support for attribute "invalidCode" when a user enters an invalid code too many times
* 2015-11-20 - Corrected text from Auto unlock to Auto lock
* 2015-11-2 - Added support to set Alarm and Sensivity levels directly from a SmartApp using setAlarm ("off", "alert", "tamper", "forced")and setSensitivity ("highest", "high", "medium", "low", "lowest") commands
* 2015-9-29 - Added support for Schlage BE369
* 2015-9-26 - Updated layout and colors
* 2015-9-23 - Updated colors and layout
* 2015-9-19 - Added support for MultiAttribute Tiles
* 2015-7-22 - Updated base code to sync with SmartThings (removed status "invalidCode" and use "tamper" instead)
* 2015-7-15 - Added support for BE468
* 2015-7-15 - Improved Jammed status support
* 2015-6-5 - Added support to get battery level on manual refresh
* 2015-6-5 - Added support for BE469 and FE599 Schlage locks
* 2015-2-13 - Added support for auto lock and vacation mode
* 2015-1-20 - Added support for configuring alarm mode and alarm sensitivity
* 2015-1-20 - Added support for motion sensor capability for alarm event
* 2015-1-20 - Added support for door jammed status using capability "invalidCode"
*
*/

metadata {
    // Automatically generated. Make future change here.
    definition (name: "Universal Z-Wave Lock With Alarms", namespace: "rboy", author: "RBoy Apps") {
        capability "Actuator"
        capability "Lock"
        capability "Polling"
        capability "Refresh"
        capability "Sensor"
        capability "Lock Codes"
        capability "Battery"
        capability "Health Check"
        capability "Configuration"
        capability "Tamper Alert"
        capability "Smoke Detector" //  Fire/Smoke Sensor alerts for IDLock
        capability "Contact Sensor" // Door Open/Close state capability for IDlock and Yale DPS
        //capability "Motion Sensor" // replaced with Tamper Alert (Uncomment this to report as Motion Sensor for tamper alarm alerts for Schlage)
        //capability "Switch" // Uncomment this to enable Switch capability interfaces on lock

        attribute "alarm", "string"
        attribute "sensitive", "string"
        attribute "codeunlock", "string"
        attribute "autolock", "string"
        attribute "lockStatus", "string"
        attribute "invalidCode", "string"
        attribute "beeper", "string"
        attribute "maxPINLength", "number"
        attribute "minPINLength", "number"
        attribute "codeLength", "number" // TODO: Do we need to define this or is this automatically done now with the new DTH capability
        attribute "maxCodes", "number" // TODO: Do we need to define this or is this automatically done now with the new DTH capability
        attribute "codeVersion", "string"
        attribute "dhName", "string"
        attribute "contactX", "string"
        attribute "onetouchlock", "string"


        //command "unlockwtimeout" // TODO Do we need this anymore or is it defined internally with the new DTH type
        command "alarmToggle"
        command "setAlarm", ["string"]
        command "sensitiveToggle"
        command "setSensitivity", ["string"]
        command "disableKeypad"
        command "enableKeypad"
        command "enableAutolock"
        command "disableAutolock"
        command "disableAudio"
        command "enableAudio"
        command "disableOneTouchLock"
        command "enableOneTouchLock"

        fingerprint deviceId: "0x4004", inClusters: "0x98"
        fingerprint deviceId: "0x4003", inClusters: "0x98"
        fingerprint deviceId: "0x4003", inClusters: "0x85,0x73,0x72,0x98" // Schalge BE369, Schlage FE599
        fingerprint deviceId: "0x4003", inClusters: "0x22,0x72,0x7A,0x98,0x86" // Schlage BE469
        fingerprint deviceId: "0x4003", inClusters: "0x72,0x86,0x98" // Kwikset 910/916/914, Yale KeyFree UK

        // New fingerprint format (MSR ==> mfr-prod-model)
        fingerprint type:"4004", cc:"98" // Generic Z-Wave lock
        fingerprint type:"4003", cc:"98" // Generic Z-Wave lock
        fingerprint type:"4003", cc:"72,86,98", deviceJoinName:"Kwikset/Yale Z-Wave Lock" // Generic Kwikset/Yale
        fingerprint type:"4003", cc:"85,73,72,98", deviceJoinName:"Schlage BE3xx/FE5xx Z-Wave Lock" // Generic Schalge BE369, Schlage FE599
        fingerprint type:"4003", cc:"22,72,7A,98,86", deviceJoinName:"Schlage BE4xx Z-Wave Lock" // Schlage Generic BE4xx

        // Specific models
        fingerprint mfr:"003B", prod:"634B", model:"5044", deviceJoinName:"Schlage FE369 Z-Wave Lock"
        fingerprint mfr:"003B", prod:"634B", model:"504C", deviceJoinName:"Schlage FE599 Z-Wave Lock"
        fingerprint mfr:"003B", prod:"6349", deviceJoinName:"Schlage Touchscreen Deadbolt BE468 Z-Wave Lock"
        fingerprint mfr:"003B", prod:"6349", model:"5044", deviceJoinName:"Schlage Touchscreen Deadbolt BE468NX CAM 619 Z-Wave Lock"
        fingerprint mfr:"003B", prod:"6341", deviceJoinName:"Schlage Touchscreen Deadbolt BE469 Z-Wave Lock" // Generic Schlage BE469
        fingerprint mfr:"003B", prod:"6341", model:"5044", deviceJoinName:"Schlage Touchscreen Deadbolt FE469NX Z-Wave Lock" // Generic Schlage FE469
        fingerprint mfr:"003B", prod:"6341", model:"5044", deviceJoinName:"Schlage Touchscreen Deadbolt BE469NX CAM 716 Z-Wave Lock"
        fingerprint mfr:"003B", prod:"6341", model:"7750", deviceJoinName:"Schlage Touchscreen Deadbolt BE469NX CEN 716 Z-Wave Lock"
        fingerprint mfr:"003B", prod:"6341", model:"4044", deviceJoinName:"Schlage Touchscreen Deadbolt BE469IR Z-Wave Lock"
        fingerprint mfr:"0090", prod:"0001", model:"0642", deviceJoinName:"Kwikset 916 Z-Wave Lock"
        fingerprint mfr:"0090", prod:"0001", model:"0436", deviceJoinName:"Kwikset 914 Z-Wave Lock"
        fingerprint mfr:"0090", prod:"0001", model:"0336", deviceJoinName:"Kwikset 912 Z-Wave Lock"
        fingerprint mfr:"0090", prod:"0001", model:"0236", deviceJoinName:"Kwikset 910 Z-Wave Lock"
        fingerprint mfr:"0090", prod:"0001", model:"0001", deviceJoinName:"Kwikset 91x Z-Wave lock" // Kwikset 91x Series Generic Z-Wave
        fingerprint mfr:"0090", prod:"0001", deviceJoinName:"Kwikset Z-Wave lock" // Kwikset Generic Z-Wave, model:"0001"
        fingerprint mfr:"0090", prod:"0003", deviceJoinName:"Vivint (Kwikset) Z-Wave lock" // Kwikset Vivint Generic Z-Wave, model:"0003"
        fingerprint mfr:"0090", prod:"0003", model:"0541", deviceJoinName:"Kwikset Z-Wave lock" // Kwikset Vivint 912
        fingerprint mfr:"0109", prod:"0002", model:"0000", deviceJoinName:"Yale Real Living Touchscreen Deadbolt"
        fingerprint mfr:"0129", prod:"0002", model:"0000", deviceJoinName:"Yale Real Living Touchscreen Deadbolt"
        fingerprint mfr:"0109", prod:"0002", model:"FFFF", deviceJoinName:"Yale Real Living Touchscreen Lever Lock"
        fingerprint mfr:"0129", prod:"0002", model:"FFFF", deviceJoinName:"Yale Real Living Touchscreen Lever Lock"
        fingerprint mfr:"0109", prod:"0001", model:"0000", deviceJoinName:"Yale Real Living Push Button Lever Lock"
        fingerprint mfr:"0129", prod:"0001", model:"0000", deviceJoinName:"Yale Real Living Push Button Lever Lock"
        fingerprint mfr:"0109", prod:"0004", model:"0000", deviceJoinName:"Yale Real Living Push Button Deadbolt"
        fingerprint mfr:"0129", prod:"0004", model:"0000", deviceJoinName:"Yale Real Living Push Button Deadbolt" // YRD 210
        fingerprint mfr:"0109", prod:"0004", model:"0800", deviceJoinName:"Yale YRD110"
        fingerprint mfr:"0129", prod:"0004", model:"0800", deviceJoinName:"Yale YRD110"
        fingerprint mfr:"0109", prod:"0002", model:"0800", deviceJoinName:"Yale YRD120"
        fingerprint mfr:"0129", prod:"0002", model:"0800", deviceJoinName:"Yale YRD120"
        fingerprint mfr:"0129", prod:"8002", model:"1600", deviceJoinName:"Yale Assure with Bluetooth (YRD446-NR-605)"
        fingerprint mfr:"0129", prod:"8002", model:"1000", deviceJoinName:"Yale Assure with Bluetooth (YRD446-ZW-2619)"
        fingerprint mfr:"0129", prod:"0006", model:"0000", deviceJoinName:"Yale Keyfree Connected/Conexis L1" // UK
        fingerprint mfr:"0129", prod:"0066", model:"0000", deviceJoinName:"Yale Conexis L1 SD-L1000-CH" // Safe.co.uk
        fingerprint mfr:"0129", prod:"0007", model:"0000", deviceJoinName:"Yale Keyless Connected YD-01" // UK - YD-01-CON-ZW-CH
        fingerprint mfr:"0129", prod:"0040", model:"0000", deviceJoinName:"Yale YDM3168" // Italy
        fingerprint mfr:"0129", prod:"8001", model:"0B00", deviceJoinName:"Yale nexTouch Wireless Touchscreen" // Yale Commercial
        fingerprint mfr:"0129", prod:"0600", model:"8004", deviceJoinName:"Yale Assure Push Button Lock" // Yale Assa Abloy series
        fingerprint mfr:"0129", prod:"0600", model:"8002", deviceJoinName:"Yale Assure Touch Screen Lock" // Yale Assa Abloy series
		fingerprint mfr:"0129", prod:"8002", model:"0600", deviceJoinName: "Yale Assure Lock" //YRD416, YRD426, YRD446
		fingerprint mfr:"0129", prod:"0007", model:"0001", deviceJoinName: "Yale Keyless Connected Smart Door Lock"
		fingerprint mfr:"0129", prod:"8004", model:"0600", deviceJoinName: "Yale Assure Lock Push Button Deadbolt" //YRD216
        fingerprint mfr:"0129", prod:"6600", model:"0002", deviceJoinName: "Yale Conexis Lock" // Yale Conexis
        fingerprint mfr:"0230", prod:"0003", model:"0001", deviceJoinName:"IDLock 101 Z-Wave/RFID Lock"
        fingerprint mfr:"0230", prod:"0003", deviceJoinName:"IDLock Z-Wave/RFID Lock"
        fingerprint mfr:"010E", prod:"0008", model:"0002", deviceJoinName:"DanaLock V2 BLE, Z-Wave EU" // Circle
        fingerprint mfr:"010E", prod:"0008", model:"0001", deviceJoinName:"DanaLock V2 BLE, Z-Wave EU" // Square
        fingerprint mfr:"010E", prod:"0009", model:"0001", deviceJoinName:"DanaLock Vv BLE, Z-Wave EU" // V3 Square
        fingerprint mfr:"010E", prod:"0009", model:"0002", deviceJoinName:"DanaLock Vv BLE, Z-Wave EU" // V3 Circle
        fingerprint mfr:"033F", prod:"0001", model:"0001", deviceJoinName:"August Lock" // August
        fingerprint mfr:"022E", prod:"0001", model:"0001", deviceJoinName:"Samsung Digital Lock" // SHP-DS705, SHP-DHP728, SHP-DHP525	
    }

    simulator {
        status "locked": "command: 9881, payload: 00 62 03 FF 00 00 FE FE"
        status "unlocked": "command: 9881, payload: 00 62 03 00 00 00 FE FE"

        reply "9881006201FF,delay 4200,9881006202": "command: 9881, payload: 00 62 03 FF 00 00 FE FE"
        reply "988100620100,delay 4200,9881006202": "command: 9881, payload: 00 62 03 00 00 00 FE FE"
    }

    preferences {
        input title: "", description: "Universal Z-Wave Lock Device Handler v${clientVersion()}", displayDuringSetup: false, type: "paragraph", element: "paragraph", required: true
        input title: "", description: "", displayDuringSetup: false, type: "paragraph", element: "paragraph"
        input title: "", description: "YALE LOCK CONFIGURATION OPTIONS", displayDuringSetup: false, type: "paragraph", element: "paragraph", required: true
        input title: "", description: "Number of invalid code entries before the lock sends a tamper alarm", displayDuringSetup: false, type: "paragraph", element: "paragraph"
        input("yaleWrongCodeLimit", "number", title:"Wrong code entry limit", description: "Wrong code entry limit", defaultValue: "5", range: "1..7", required: false, displayDuringSetup: false)
        input title: "", description: "Number of seconds after which the lock will automatically relock when AutoLock is enabled", displayDuringSetup: false, type: "paragraph", element: "paragraph"
        input("yaleRelockTime", "number", title:"AutoLock time", description: "Seconds after which the lock will relock", defaultValue: "30", range: "5..255", required: false, displayDuringSetup: false)
        input title: "", description: "Enable this if your lock is equipped with a door positioning sensor to sense open/closed doors", displayDuringSetup: false, type: "paragraph", element: "paragraph"
        input("yaleDPS", "bool", title:"DPS", description: "Door Positioning Sensor", defaultValue: "false", required: false, displayDuringSetup: false)
        input title: "", description: "", displayDuringSetup: false, type: "paragraph", element: "paragraph"
        input title: "", description: "DANALOCK CONFIGURATION OPTIONS", displayDuringSetup: false, type: "paragraph", element: "paragraph", required: true
        input title: "", description: "Turning speed (torque) of motor", displayDuringSetup: false, type: "paragraph", element: "paragraph"
        input("danaTurnSpeed", "enum", title:"Motor speed", description: "Speed of locking and unlocking", defaultValue: "3", options: turnOptions(), required: false, displayDuringSetup: false)
        input title: "", description: "Brake and go back: (If your lock supports this feature) For doors without levers this feature keeps the latch open for a few seconds after unlocking before turning it back. (0 to disable)", displayDuringSetup: false, type: "paragraph", element: "paragraph"
        input("danaBrakeGoBack", "number", title:"Brake & Go Back time", description: "Number of seconds to keep the latch open after unlocking", defaultValue: "0", range: "0..2147483647", required: false, displayDuringSetup: false)
        input title: "", description: "Number of seconds after which the lock will automatically relock when AutoLock is enabled", displayDuringSetup: false, type: "paragraph", element: "paragraph"
        input("danaRelockTime", "number", title:"AutoLock time", description: "Seconds after which the lock will relock", defaultValue: "30", range: "1..2147483647", required: false, displayDuringSetup: false)
        input title: "", description: "Turn and Go: (If your lock supports this feature) If the lock has the optional rotational sensor installed it will automatically turn if manual rotation is detected", displayDuringSetup: false, type: "paragraph", element: "paragraph"
        input("danaTurnGo", "bool", title:"Turn & Go", description: "Enable Turn & Go", defaultValue: "false", required: false, displayDuringSetup: false)
    }

    tiles(scale: 2) {
        multiAttributeTile(name:"toggle", type: "generic", width: 6, height: 4){
            tileAttribute ("device.lock", key: "PRIMARY_CONTROL") {
                attributeState "locked", label:'locked', action:"lock.unlock", icon:"st.locks.lock.locked", backgroundColor:"#00a0dc", nextState:"unlocking"
                attributeState "unlocked", label:'unlocked', action:"lock.lock", icon:"st.locks.lock.unlocked", backgroundColor:"#ffffff", nextState:"locking"
                attributeState "unlocked with timeout", label:'unlocked', action:"lock.lock", icon:"st.locks.lock.unlocked", backgroundColor:"#ffffff", nextState:"locking"
                attributeState "unknown", label:"jammed", action:"lock.lock", icon:"st.locks.lock.unknown", backgroundColor:"#e86d13", nextState:"locking"
                attributeState "locking", label:'locking', icon:"st.locks.lock.locked", backgroundColor:"#00a0dc"
                attributeState "unlocking", label:'unlocking', icon:"st.locks.lock.unlocked", backgroundColor:"#ffffff"
            }
            tileAttribute ("device.lockStatus", key: "SECONDARY_CONTROL") {
                attributeState "lockStatus", label:'${currentValue}'
            }
        }
        standardTile("lock", "device.lock", inactiveLabel: false, decoration: "flat", width: 2, height: 2) {
            state "default", label:'Lock', action:"lock.lock", icon:"st.locks.lock.locked"
        }
        standardTile("unlock", "device.lock", inactiveLabel: false, decoration: "flat", width: 2, height: 2) {
            state "default", label:'Unlock', action:"lock.unlock", icon:"st.locks.lock.unlocked"
        }
        standardTile("alarm", "device.alarm", inactiveLabel: false, decoration: "flat", width: 2, height: 2) {
            state "unknown", label:'', icon:"", nextState:"workingoff", backgroundColor:"#ffffff", defaultState: true
            state "off", label:'Alarm Off', action:"alarmToggle", icon:"http://smartthings.rboyapps.com/images/SecurityOff.png", nextState:"workingoff"
            state "alert", label:'Alert Mode', action:"alarmToggle", icon:"http://smartthings.rboyapps.com/images/SecurityOn.png", nextState:"workingon"
            state "tamper", label:'Tamper Mode', action:"alarmToggle", icon:"http://smartthings.rboyapps.com/images/SecurityOn.png", nextState:"workingon"
            state "forced", label:'Forced Mode', action:"alarmToggle", icon:"http://smartthings.rboyapps.com/images/SecurityOn.png", nextState:"workingon"
            state "workingoff", label:'...', icon:"http://smartthings.rboyapps.com/images/SecurityOff.png", backgroundColor:"#ffffff"
            state "workingon", label:'...', icon:"http://smartthings.rboyapps.com/images/SecurityOn.png", backgroundColor:"#ffffff"
        }
        standardTile("sensitive", "device.sensitive", inactiveLabel: false, decoration: "flat", width: 2, height: 2) {
            state "unknown", label:'', icon:"", nextState:"working", backgroundColor:"#ffffff", defaultState: true
            state "highest", label:'Highest Sensitivity', action:"sensitiveToggle", icon:"http://smartthings.rboyapps.com/images/Sensitivity.png", nextState:"working"
            state "high", label:'High Sensitivity', action:"sensitiveToggle", icon:"http://smartthings.rboyapps.com/images/Sensitivity.png", nextState:"working"
            state "medium", label:'Medium Sensitivity', action:"sensitiveToggle", icon:"http://smartthings.rboyapps.com/images/Sensitivity.png", nextState:"working"
            state "low", label:'Low Sensitivity', action:"sensitiveToggle", icon:"http://smartthings.rboyapps.com/images/Sensitivity.png", nextState:"working"
            state "lowest", label:'Lowest Sensitivity', action:"sensitiveToggle", icon:"http://smartthings.rboyapps.com/images/Sensitivity.png", nextState:"working"
            state "working", label:'...', icon:"http://smartthings.rboyapps.com/images/Sensitivity.png", backgroundColor:"#ffffff"
        }
        standardTile("onetouchlock", "device.onetouchlock", inactiveLabel: false, decoration: "flat", width: 2, height: 2) {
            state "unknown", label:'', icon:"", backgroundColor:"#ffffff", nextState:"working", defaultState: true
            state "enabled", label:'Touch Lock', action:"disableOneTouchLock", icon:"http://smartthings.rboyapps.com/images/ManualControlOn.png", nextState:"working"
            state "disabled", label:'Touch Lock', action:"enableOneTouchLock", icon:"http://smartthings.rboyapps.com/images/ManualControlOff.png", nextState:"working"
            state "working", label:'...', icon:"http://smartthings.rboyapps.com/images/ManualControlWorking.png", backgroundColor:"#cccccc"
        }
        standardTile("codeunlock", "device.codeunlock", inactiveLabel: false, decoration: "flat", width: 2, height: 2) {
            state "unknown", label:'', icon:"", backgroundColor:"#ffffff", nextState:"working", defaultState: true
            state "enabled", label:'Code Entry On', action:"disableKeypad", icon:"st.unknown.zwave.remote-controller", backgroundColor:"#ffffff", nextState:"working"
            state "disabled", label:'Code Off', action:"enableKeypad", icon:"st.unknown.zwave.remote-controller", backgroundColor:"#00a0dc", nextState:"working"
            state "working", label:'...', icon:"st.unknown.zwave.remote-controller", backgroundColor:"#cccccc"
        }
        standardTile("autolock", "device.autolock", inactiveLabel: false, decoration: "flat", width: 2, height: 2) {
            state "unknown", label:'', icon:"", backgroundColor:"#ffffff", nextState:"working", defaultState: true
            state "enabled", label:'AutoLock', action:"disableAutolock", icon:"st.contact.contact.closed", backgroundColor:"#00a0dc", nextState:"working"
            state "disabled", label:'AutoLock Off', action:"enableAutolock", icon:"st.contact.contact.closed", nextState:"working"
            state "working", label:'...', icon:"st.contact.contact.closed", backgroundColor:"#cccccc"
        }
        standardTile("beeper", "device.beeper", inactiveLabel: false, decoration: "flat", width: 2, height: 2) {
            state "unknown", label:'', icon:"", backgroundColor:"#ffffff", nextState:"workingoff", defaultState: true
            state "enabled", label:'Audio On', action:"disableAudio", icon:"st.quirky.spotter.quirky-spotter-sound-on", backgroundColor:"#ffffff", nextState:"workingon"
            state "disabled", label:'Audio Off', action:"enableAudio", icon:"st.quirky.spotter.quirky-spotter-sound-off", nextState:"workingoff"
            state "workingoff", label:'...', icon:"st.quirky.spotter.quirky-spotter-sound-off", backgroundColor:"#ffffff"
            state "workingon", label:'...', icon:"st.quirky.spotter.quirky-spotter-sound-on", backgroundColor:"#ffffff"
        }
        valueTile("battery", "device.battery", inactiveLabel: false, width: 2, height: 2) {
            state "battery", label:'${currentValue}%', icon: "http://smartthings.rboyapps.com/images/battery.png", unit:"", backgroundColors:[
                [value: 20, color: "#ff0000"],
                [value: 35, color: "#fd4e3a"],
                [value: 50, color: "#fda63a"],
                [value: 60, color: "#fdeb3a"],
                [value: 75, color: "#d4fd3a"],
                [value: 90, color: "#7cfd3a"],
                [value: 99, color: "#55fd3a"]
            ]
        }
        standardTile("refresh", "device.lock", inactiveLabel: false, decoration: "flat", width: 2, height: 2) {
            state "default", label:'', action:"refresh.refresh", icon:"st.secondary.refresh"
        }
        standardTile("tamper", "device.tamper", decoration: "flat", width: 2, height: 2) {
            state "unknown", label:'', icon:"", backgroundColor:"#ffffff", defaultState: true
            state "detected", label:'TAMPER', backgroundColor:"#e86d13"
            state "clear", label:'', backgroundColor:"#ffffff"
        }
        standardTile("smoke", "device.smoke", decoration: "flat", width: 2, height: 2) {
            state "unknown", label:'', icon:"", backgroundColor:"#ffffff", defaultState: true
            state "clear", label:'', icon:"", backgroundColor:"#ffffff", action:"smoke"
            state "detected", label:'SMOKE', icon:"st.alarm.smoke.smoke", backgroundColor:"#e86d13", action:"clear"
        }
        standardTile("contact", "device.contactX", decoration: "flat", width: 2, height: 2) {
            state "unknown", label:'', icon:"", backgroundColor:"#ffffff", defaultState: true
            state "open", label: 'OPEN', icon: "st.contact.contact.open", backgroundColor: "#e86d13"
            state "closed", label: 'CLOSED', icon: "st.contact.contact.closed", backgroundColor: "#00a0dc"
        }
        standardTile("blank", "device.image", width: 1, height: 1, canChangeIcon: false,  canChangeBackground: false, decoration: "flat") {
            state "blank", label: "", action: "", icon: "", backgroundColor: "#FFFFFF"
        }
        standardTile("blank2x", "device.image", width: 2, height: 2, canChangeIcon: false,  canChangeBackground: false, decoration: "flat") {
            state "blank", label: "", action: "", icon: "", backgroundColor: "#FFFFFF"
        }

        main "toggle"
        details(["toggle", "lock", "unlock", "codeunlock", "autolock", "beeper", "onetouchlock", "alarm", "sensitive", "battery", "contact", "tamper", "smoke", "blank2x", "blank2x", "refresh"])
    }
}

import physicalgraph.zwave.commands.doorlockv1.*
import physicalgraph.zwave.commands.usercodev1.*

private turnOptions() {
    return [1:"Slowest", 2:"Slow", 3:"Normal", 4:"Fast", 5:"Fastest"]
}

private identifyLockModel() {
    log.trace "Identifying specific lock model from database of known models"

    switch (state.MSR) { // check if we have a supported device
        case "003B-6341-5044": // Schlage FE/BE469NX CAM 716
            log.debug "Found Schlage FE/BE469NX CAM 716"
            break

        case "003B-6341-7750": // Schlage FE/BE469NX CEN 716
            log.debug "Found Schlage FE/BE469NX CEN 716"
            break

        case "003B-6341-4044": // Schlage FE/BE469IR V CAM 619
            log.debug "Found Schlage FE/BE469IR V CAM 619"
            break

        case ~/003B-6341-.*/: // Schlage FE/BE469 Series
            log.debug "Found Schlage FE/BE469 Series"
            break

        case "003B-6349-5044": // Schlage BE468
            log.debug "Found Schlage BE468"
            break

        case ~/003B-6349-.*/: // Schlage BE468 Series
            log.debug "Found Schlage BE468 Series"
            break

        case "003B-634B-504C": // Schlage FE599NX CAM 505 ACC 505
            log.debug "Found Schlage FE599NX CAM 505 ACC 505"
            break

        case "003B-634B-5044": // Schlage BE369NX CAM 619
            log.debug "Found Schlage BE369NX CAM 619"
            break

        case ~/003B-634B-.*/: // Schlage FE5xx/BE3xx Series
            log.debug "Found Schlage FE5xx/BE3xx Series"
            break

        case ~/0109-0001-.*/: // Yale Touch Lever
        case ~/0129-0001-.*/: // Yale Touch Lever
            log.debug "Found Yale Touch Lever"
            break

        case ~/0109-0002-.*/: // Yale Touch Deadbolt
        case ~/0129-0002-.*/: // Yale Touch Deadbolt
            log.debug "Found Yale Touch Deadbolt"
            break

        case ~/0109-0003-.*/: // Yale Push Button Lever
        case ~/0129-0003-.*/: // Yale Push Button Lever
            log.debug "Found Yale Push Button Lever"
            break

        case ~/0109-0004-.*/: // Yale Push Button Deadbolt
        case ~/0129-0004-.*/: // Yale Push Button Deadbolt
            log.debug "Found Yale Push Button Deadbolt"
            break

        case ~/0129-0006-.*/: // Yale Keyfree/Conexis L1 Lock
            log.debug "Found Yale Keyfree/Conexis L1 Lock"
            break

        case ~/0129-6600-.*/: // Yale Conexis
        case ~/0129-0066-.*/: // Yale Yale Conexis L1 SD-L1000-CH Safe.co.uk
            log.debug "Found Yale Conexis Lock"
            break

        case ~/0129-0007-.*/: // Yale Keyless Connected YD-01
            log.debug "Found Yale Keyless Connected YD-01"
            break

        case ~/0129-8001-.*/: // Yale nextTouch Wireless Touchscreen
            log.debug "Found Yale nexTouch"
            break

        case ~/0129-8002-.*/: // Yale Assure Lock
            log.debug "Found Yale Assure"
            break

        case ~/0129-8004-.*/: // Yale Yale Assure Lock Push Button Deadbolt
            log.debug "Found Yale Assure Lock Push Button Deadbolt"
            break

        case ~/0129-0600-.*/: // Yale Assure Assa Abloy
            log.debug "Found Yale Assure Assa Abloy Lock"
            break

        case "0090-0001-0642": // Kwikset 916
            log.debug "Found Kwikset 916 Lock"
            break

        case "0090-0001-0436": // Kwikset 914
            log.debug "Found Kwikset 914 Lock"
            break

        case "0090-0001-0336": // Kwikset 912
            log.debug "Found Kwikset 912 Lock"
	        break

        case "0090-0001-0236": // Kwikset 910
            log.debug "Found Kwikset 910 Lock"
            break

        case "0090-0001-0001": // Kwikset 91x Series
            log.debug "Found Kwikset 91x Lock"
            break

        case ~/0090-0001-.*/: // Kwikset 916/914/910
            log.debug "Found Kwikset Lock"
            break
        
        case "0090-0003-0541": // Vivint Kwikset 912 variant
        	log.debug "Found Vivint Kwikset 912 Lock"
        	break

        case "0230-0003-0001": // IDLock 101
            log.debug "Found IDLock 101 Lock"
            break

        case ~/0230-0003-.*/: // IDLock 1xx
            log.debug "Found IDLock 1xx Lock"
            break

        case ~/010E-0009-.*/: // Danalock V3
            log.debug "Found Danalock v3"
            break

        case ~/010E-0008-.*/: // Danalock V2
	        log.debug "Found Danalock v2"
    	    break

        case ~/033F-0001-.*/: // August
            log.debug "Found August Lock"
            break

        case ~/022E-0001-.*/: // Samsung
            log.debug "Found Samsung Digital Lock"
            break

        default:
            log.warn "Unrecognized device. Contact developer with MSR $state.MSR"
	        break
    }
}	

/**
* Called on app installed
*/
def installed() {
    // Device-Watch pings if no device events received for 1 hour (checkInterval)
    sendEvent(name: "checkInterval", value: 1 * 60 * 60, displayed: false, data: [protocol: "zwave", hubHardwareId: device.hub.hardwareID, offlinePingable: "1"])
}

/**
* Called on app uninstalled
*/
def uninstalled() {
    def deviceName = device.displayName
    log.trace "[DTH] Executing 'uninstalled()' for device $deviceName"
    sendEvent(name: "lockRemoved", value: device.id, isStateChange: true, displayed: false)
}

/**
* Executed when the user taps on the 'Done' button on the device settings screen. Sends the values to lock.
*
* @return hubAction: The commands to be executed
*/
def updated() {
    log.trace "Updated called settings: $settings"
    // Device-Watch pings if no device events received for 1 hour (checkInterval)
    sendEvent(name: "checkInterval", value: 1 * 60 * 60, displayed: false, data: [protocol: "zwave", hubHardwareId: device.hub.hardwareID, offlinePingable: "1"])
    def hubAction = null
    try {
        def cmds = []
        state.configured = false

        // Reset things which cannot be polled / updated manually
        resetMotion()
        resetSmoke()
        resetState()

        cmds << refresh()
        //cmds << reloadAllCodes() // TODO: Should we reload codes each time it is configured or just first time when it loads
        if (!state.init) {
            state.init = true
        }

        hubAction = response(delayBetween(cmds, 4200))
    } catch (e) {
        log.warn "updated() threw $e"
    }

    hubAction
}

/**
 * Configures the device to settings needed by SmarthThings at device discovery time
 *
 */
def configure() {
	log.trace "[DTH] Executing 'configure()' for device ${device.displayName}"
	def cmds = doConfigure()
	log.debug "Configure returning with commands := $cmds"
	cmds
}

/**
 * Returns the list of commands to be executed when the device is being configured/paired
 *
 */
def doConfigure() {
	log.trace "[DTH] Executing 'doConfigure()' for device ${device.displayName}"
	state.configured = true
	def cmds = []
	cmds << secure(zwave.doorLockV1.doorLockOperationGet())
	cmds << getBatteryState()
    cmds << getCodeLength()
	cmds = delayBetween(cmds, 4200)
	log.debug "Do configure returning with commands := $cmds"
	cmds
}

def updateTiles() {
    def lockStatusS = (device.currentState('alarm')?.value && (device.currentState('alarm')?.value != "unknown") ? "Alarm ${device.currentState('alarm')?.value}" + (device.currentState('sensitive')?.value && (device.currentState('sensitive')?.value != "unknown") ? "/${device.currentState('sensitive')?.value} | ": " | ") : "") + "Battery ${device.currentState('battery')?.value}%"
    sendEvent(name: "lockStatus", value: lockStatusS, displayed: false, isStateChange: true)
    //log.trace lockStatusS
}

/**
 * Responsible for parsing incoming device messages to generate events
 *
 * @param description: The incoming description from the device
 *
 * @return result: The list of events to be sent out
 *
 */
def parse(String description) {
	//log.trace "[DTH] Executing 'parse(String description)' for device ${device.displayName} with description = $description"

	def result = null
	if (description.startsWith("Err")) {
		if (state.sec) {
			result = createEvent(descriptionText:description, isStateChange:true, displayed:false)
		} else {
			result = createEvent(
					descriptionText: "This lock failed to complete the network security key exchange. If you are unable to control it via SmartThings, you must remove it from your network and add it again.",
					eventType: "ALERT",
					name: "secureInclusion",
					value: "failed",
					displayed: true,
					)
		}
	} else {
		def cmd = zwave.parse(description, [ 0x98: 1, 0x72: 2, 0x85: 2, 0x86: 1 ])
		if (cmd) {
			result = zwaveEvent(cmd)
		}
	}
    updateTiles() // Update the alarm status on the tiles
	log.info "[DTH] parse() - returning result=$result"
	result
}

/**
 * Responsible for parsing SecurityMessageEncapsulation command
 *
 * @param cmd: The SecurityMessageEncapsulation command to be parsed
 *
 * @return The event(s) to be sent out
 *
 */
def zwaveEvent(physicalgraph.zwave.commands.securityv1.SecurityMessageEncapsulation cmd) {
	//log.trace "[DTH] Executing 'zwaveEvent(physicalgraph.zwave.commands.securityv1.SecurityMessageEncapsulation)' with cmd = $cmd"
	def encapsulatedCommand = cmd.encapsulatedCommand([0x62: 1, 0x71: 2, 0x80: 1, 0x85: 2, 0x63: 1, 0x98: 1, 0x86: 1])
	if (encapsulatedCommand) {
        //log.trace "[DTH] Executing 'zwaveEvent(physicalgraph.zwave.commands.securityv1.SecurityMessageEncapsulation)' with encapsulated cmd = $encapsulatedCommand"
		zwaveEvent(encapsulatedCommand)
	}
}

/**
 * Responsible for parsing NetworkKeyVerify command
 *
 * @param cmd: The NetworkKeyVerify command to be parsed
 *
 * @return The event(s) to be sent out
 *
 */
def zwaveEvent(physicalgraph.zwave.commands.securityv1.NetworkKeyVerify cmd) {
	log.trace "[DTH] Executing 'zwaveEvent(physicalgraph.zwave.commands.securityv1.NetworkKeyVerify)' with cmd = $cmd"
	createEvent(name:"secureInclusion", value:"success", descriptionText:"Secure inclusion was successful", isStateChange: true)
}

/**
 * Responsible for parsing SecurityCommandsSupportedReport command
 *
 * @param cmd: The SecurityCommandsSupportedReport command to be parsed
 *
 * @return The event(s) to be sent out
 *
 */
def zwaveEvent(physicalgraph.zwave.commands.securityv1.SecurityCommandsSupportedReport cmd) {
	log.trace "[DTH] Executing 'zwaveEvent(physicalgraph.zwave.commands.securityv1.SecurityCommandsSupportedReport)' with cmd = $cmd"
	state.sec = cmd.commandClassSupport.collect { String.format("%02X ", it) }.join()
	if (cmd.commandClassControl) {
		state.secCon = cmd.commandClassControl.collect { String.format("%02X ", it) }.join()
	}
	createEvent(name:"secureInclusion", value:"success", descriptionText:"Lock is securely included", isStateChange: true)
}

/**
 * Responsible for parsing DoorLockOperationReport command
 *
 * @param cmd: The DoorLockOperationReport command to be parsed
 *
 * @return The event(s) to be sent out
 *
 */
def zwaveEvent(DoorLockOperationReport cmd) {
    log.trace "[DTH] Executing 'zwaveEvent(DoorLockOperationReport)' with cmd = $cmd"
	def result = []

	unschedule("followupStateCheck")
	unschedule("stateCheck")

    if (isAugustLock()) { // August lock pro has a firmware bug and reports a doorLockMode of 254, ignore it (zw:Fs type:4003 mfr:033F prod:0001 model:0001 ver:0.38 zwv:4.61 lib:03 cc:5E,55,98,9F sec:86,72,5A,73,80,62,85,8E,59,6C,7A role:07 ff:8300 ui:8300)
        if (cmd.doorLockMode == 0xFE) {
            log.trace "August lock firmware bug, ignoring 0xFE door lock report"
            return
        }
    }

	// DoorLockOperationReport is called when trying to read the lock state or when the lock is locked/unlocked from the DTH or the smart app
	def map = [ name: "lock" ]
	map.data = [ lockName: device.displayName ]
	if (cmd.doorLockMode == 0xFF) {
		map.value = "locked"
		map.descriptionText = "Locked"
	} else if (cmd.doorLockMode >= 0x40) {
		map.value = "unknown"
		map.descriptionText = "Unknown state"
	} else if (cmd.doorLockMode == 0x01) {
		map.value = "unlocked with timeout"
		map.descriptionText = "Unlocked with timeout"
	}  else {
		map.value = "unlocked"
		map.descriptionText = "Unlocked"
		if (state.assoc != zwaveHubNodeId) {
			result << response(secure(zwave.associationV1.associationSet(groupingIdentifier:1, nodeId:zwaveHubNodeId)))
			result << response(zwave.associationV1.associationSet(groupingIdentifier:2, nodeId:zwaveHubNodeId))
			result << response(secure(zwave.associationV1.associationGet(groupingIdentifier:1)))
		}
	}

    // IDLock and August supports reporting door state, see Z-Wave specs check bit 0 for door state
    if (isIDLock() || isAugustLock()) { // IDLock and August
        if ((cmd.doorCondition & 1) == 0) { // Door open
            setState("open", "$device.displayName is open")
        } else if ((cmd.doorCondition & 1) == 1) { // Door closed
            setState("closed", "$device.displayName is closed")
        }
    }

	if (generatesDoorLockOperationReportBeforeAlarmReport()) {
		// we're expecting lock events to come after notification events, but for specific yale locks they come out of order
		runIn(3, "delayLockEvent", [data: [map: map]])
        return [:]
	} else {
		return result ? [createEvent(map), *result] : createEvent(map)
	}
}

def delayLockEvent(data) {
	log.debug "Sending cached lock operation: $data.map"
	sendEvent(data.map)
}

/**
 * Responsible for parsing AlarmReport command
 *
 * @param cmd: The AlarmReport command to be parsed
 *
 * @return The event(s) to be sent out
 *
 */
def zwaveEvent(physicalgraph.zwave.commands.alarmv2.AlarmReport cmd) {
	log.trace "[DTH] Executing 'zwaveEvent(physicalgraph.zwave.commands.alarmv2.AlarmReport)' with cmd = $cmd"
	def result = []
	
	if (cmd.zwaveAlarmType == 6) {
		result = handleAccessAlarmReport(cmd)
	} else if (cmd.zwaveAlarmType == 7) {
		result = handleBurglarAlarmReport(cmd)
	} else if(cmd.zwaveAlarmType == 8) {
		result = handleBatteryAlarmReport(cmd)
	} else if(cmd.zwaveAlarmType == 0xA) {
		result = handleEmergencyAlarmReport(cmd)
	} else {
		result = handleAlarmReportUsingAlarmType(cmd)
	}
		
	result = result ?: null
	log.debug "[DTH] zwaveEvent(physicalgraph.zwave.commands.alarmv2.AlarmReport) returning with result = $result"
	result
}

/**
 * Responsible for handling Access AlarmReport command
 *
 * @param cmd: The AlarmReport command to be parsed
 *
 * @return The event(s) to be sent out
 *
 */
private def handleAccessAlarmReport(cmd) {
	log.trace "[DTH] Executing 'handleAccessAlarmReport' with cmd = $cmd"
	def result = []
	def map = null
	def codeID, changeType, lockCodes, codeName
	def deviceName = device.displayName
	lockCodes = loadLockCodes()
	if (1 <= cmd.zwaveAlarmEvent && cmd.zwaveAlarmEvent < 10) {
		map = [ name: "lock", value: (cmd.zwaveAlarmEvent & 1) ? "locked" : "unlocked" ]
	}
	switch(cmd.zwaveAlarmEvent) {
		case 1: // Manually locked
			map.descriptionText = "Locked manually"
			map.data = [ method: (cmd.alarmLevel == 2) ? "keypad" : "manual" ] // Yale Assure Deadbolt has alarmLevel as 2 for external keypad lock and 1 for internal knob lock
			break
		case 2: // Manually unlocked
			map.descriptionText = "Unlocked manually"
			map.data = [ method: "manual" ]
			break
		case 3: // Locked by command, Danalock/Yale RF Lock
			map.descriptionText = "Locked"
			map.data = [ method: "command" ]
			break
		case 4: // Unlocked by command, RF Unlock
			if (cmd.eventParameter) { // IDLock RFID
				codeID = cmd.eventParameter[0] - (isIDLock() ? 9 : 0)
				codeName = getCodeName(lockCodes, codeID)
				map.descriptionText = "Unlocked by \"$codeName\""
				map.data = [ usedCode: codeID, method: "rfid" ] // IDLock report starts from 10 for the 1st registered card
            } else { // Yale and Danalock RF
				map.descriptionText = "Unlocked"
				map.data = [ method: "command" ]
            }

			break
		case 5: // Locked with keypad
			// Schlage locked from outside via keypad (alarmLevel=0 for no code lock and leave, alarmLevel=1 for with code)
			if (cmd.eventParameter || cmd.alarmLevel) {
				codeID = readCodeSlotId(cmd)
				codeID = (isKwiksetLock() || isSchlageLock()) ? (codeID ?: null) : codeID // Schlage/Kwikset locks report 0 for outside button/one touch lock (don't use 0 as it's considered Master Code, report null for Schlage/Kwikset)
			}
			if (codeID != null) {
				codeName = getCodeName(lockCodes, codeID)
				map.descriptionText = "Locked by \"$codeName\""
				map.data = [ usedCode: codeID, codeName: codeName, method: "keypad" ]
			} else { 
				// locked by pressing the Schlage button
				map.descriptionText = "Locked manually"
				map.data = [ method: "keypad" ]
			}
			break
		case 6: // Unlocked with keypad
			// Schlage locked from outside via keypad (alarmLevel=0 for no code lock and leave, alarmLevel=1 for with code)
			if (cmd.eventParameter || cmd.alarmLevel) {
				codeID = readCodeSlotId(cmd)
				codeID = (isKwiksetLock() || isSchlageLock()) ? (codeID ?: null) : codeID // Schlage/Kwikset locks report 0 for outside button/one touch lock (don't use 0 as it's considered Master Code, report null for Schlage/Kwikset)
			}
			if (codeID != null) {
				codeName = getCodeName(lockCodes, codeID)
				map.descriptionText = "Unlocked by \"$codeName\""
				map.data = [ usedCode: codeID, codeName: codeName, method: "keypad" ]
			} else { 
				map.descriptionText = "Unlocked manually"
				map.data = [ method: "keypad" ]
			}
			break
		case 7:
			map = [ name: "lock", value: "unknown", descriptionText: "Unknown state" ]
			map.data = [ method: "manual" ]
			break
		case 8:
			map = [ name: "lock", value: "unknown", descriptionText: "Unknown state" ]
			map.data = [ method: "command" ]
			break
		case 9: // Auto locked
			map = [ name: "lock", value: "locked", data: [ method: "auto" ] ]
			map.descriptionText = "Auto locked"
			break
		case 0xA:
			map = [ name: "lock", value: "unknown", descriptionText: "Unknown state" ]
			map.data = [ method: "auto" ]
			break
		case 0xB:
			map = [ name: "lock", value: "unknown", descriptionText: "Unknown state" ]
			break
		case 0xC: // All user codes deleted
			result = allCodesDeletedEvent()
			map = [ name: "codeChanged", value: "all deleted", descriptionText: "Deleted all user codes", isStateChange: true ]
			map.data = [notify: true, notificationText: "Deleted all user codes in $deviceName at ${location.name}"]
			result << createEvent(name: "lockCodes", value: util.toJson([:]), displayed: false, descriptionText: "'lockCodes' attribute updated")
			break
		case 0xD: // User code deleted
			if (cmd.eventParameter || cmd.alarmLevel) {
				codeID = readCodeSlotId(cmd)
				if (lockCodes[codeID.toString()]) {
					codeName = getCodeName(lockCodes, codeID)
					map = [ name: "codeChanged", value: "$codeID deleted", isStateChange: true ]
					map.descriptionText = "Deleted \"$codeName\""
					map.data = [ codeName: codeName, notify: true, notificationText: "Deleted \"$codeName\" in $deviceName at ${location.name}" ]
					result << codeDeletedEvent(lockCodes, codeID)
				}
			}
			break
		case 0xE: // Master or user code changed/set
			if (cmd.eventParameter || cmd.alarmLevel) {
				codeID = readCodeSlotId(cmd)
				if(codeID == 0 && isKwiksetLock()) {
					//Ignoring this AlarmReport as Kwikset reports codeID 0 when all slots are full and user tries to set another lock code manually
					//Kwikset locks don't send AlarmReport when Master code is set
					log.trace "Ignoring this alarm report in case of Kwikset locks"
					break
				}
				codeName = getCodeNameFromState(lockCodes, codeID)
				changeType = getChangeType(lockCodes, codeID)
				map = [ name: "codeChanged", value: "$codeID $changeType",  descriptionText: "${getStatusForDescription(changeType)} \"$codeName\"", isStateChange: true ]
				map.data = [ codeName: codeName, notify: true, notificationText: "${getStatusForDescription(changeType)} \"$codeName\" in $deviceName at ${location.name}" ]
				if(!isMasterCode(codeID)) {
					result << codeSetEvent(lockCodes, codeID, codeName)
				} else {
					map.descriptionText = "${getStatusForDescription('set')} \"$codeName\""
					map.data.notificationText = "${getStatusForDescription('set')} \"$codeName\" in $deviceName at ${location.name}"
				}
			}
			break
		case 0xF: // Duplicate Pin-code error
			if (cmd.eventParameter || cmd.alarmLevel) {
				codeID = readCodeSlotId(cmd)
				clearStateForSlot(codeID)
				map = [ name: "codeChanged", value: "$codeID failed", descriptionText: "User code is duplicate and not added",
					isStateChange: true, data: [isCodeDuplicate: true] ]
			}
			break
		case 0x10: // Tamper Alarm
		case 0x13:
			map = [ name: "invalidCode", value: "detected", descriptionText: "Keypad attempts exceed code entry limit", isStateChange: true, displayed: true ]
			break
		case 0x14: // IDLock invalid RFID code (5 bytes long) and Danalock invalid RF code
			map = [ name: "invalidCode", value: "detected", descriptionText: "Invalid code ${cmd.eventParameter.join("")}", isStateChange: true, displayed: true ]
			break
		case 0x11: // Keypad busy
			map = [ descriptionText: "Keypad is busy" ]
			break
		case 0x12: // Master code changed
			codeName = getCodeNameFromState(lockCodes, 0)
			map = [ name: "codeChanged", value: "0 set", descriptionText: "${getStatusForDescription('set')} \"$codeName\"", isStateChange: true ]
			map.data = [ codeName: codeName, notify: true, notificationText: "${getStatusForDescription('set')} \"$codeName\" in $deviceName at ${location.name}" ]
			break
		case 0x16: // DPS Open
			setState("open", "$device.displayName is open")
			map = [ descriptionText: "$device.displayName: DPS Open", displayed: false ]
			break
		case 0x17: // DPS Closed
			setState("closed", "$device.displayName is closed")
			map = [ descriptionText: "$device.displayName: DPS Closed", displayed: false ]
			break
		case 0xFE:
			// delegating it to handleAlarmReportUsingAlarmType
			return handleAlarmReportUsingAlarmType(cmd)
		default:
			// delegating it to handleAlarmReportUsingAlarmType
			return handleAlarmReportUsingAlarmType(cmd)
	}
	
	if (map) {
		if (map.data) {
			map.data.lockName = deviceName
		} else {
			map.data = [ lockName: deviceName ]
		}
		result << createEvent(map)
	}
	result = result.flatten()
	result
}

/**
 * Responsible for handling Burglar AlarmReport command
 *
 * @param cmd: The AlarmReport command to be parsed
 *
 * @return The event(s) to be sent out
 *
 */
private def handleBurglarAlarmReport(cmd) {
	log.trace "[DTH] Executing 'handleBurglarAlarmReport' with cmd = $cmd"
	def result = []
	def deviceName = device.displayName
	
	def map = [ name: "tamper", value: "detected" ]
	map.data = [ lockName: deviceName ]
	switch (cmd.zwaveAlarmEvent) {
		case 0:
			map.value = "clear"
			map.descriptionText = "Tamper alert cleared"
			break
		case 1:
		case 2: // Forced mode Schlage (no reset sent)
			activateMotion("$device.displayName: Door tampering activity detected")
			runIn(60, deactivateMotion) // Clear motion and tamper after 60 seconds, since tamper clear is never sent by a lock
			map.descriptionText = "Intrusion attempt detected"
			break
        case 8: // Samsung motion detection
		case 3:
			activateMotion("$device.displayName: Door tampering activity detected")
			runIn(60, deactivateMotion) // Clear motion and tamper after 60 seconds, since tamper clear is never sent by a lock
			map.descriptionText = "Covering removed"
			break
		case 4:
			map = [ name: "invalidCode", value: "detected", descriptionText: "Invalid code", isStateChange: true, displayed: true ]
			break
		default:
			// delegating it to handleAlarmReportUsingAlarmType
			return handleAlarmReportUsingAlarmType(cmd)
	}
	
	result << createEvent(map)
	result
}

/**
 * Responsible for handling Battery AlarmReport command
 *
 * @param cmd: The AlarmReport command to be parsed
 *
 * @return The event(s) to be sent out
 */
private def handleBatteryAlarmReport(cmd) {
	log.trace "[DTH] Executing 'handleBatteryAlarmReport' with cmd = $cmd"
	def result = []
	def deviceName = device.displayName
	def map = null
	switch(cmd.zwaveAlarmEvent) {
		case 0x0A:
			map = [ name: "battery", value: 1, descriptionText: "Battery level critical", displayed: true, data: [ lockName: deviceName ] ]
			break
		case 0x0B:
			map = [ name: "battery", value: 0, descriptionText: "Battery too low to operate lock", isStateChange: true, displayed: true, data: [ lockName: deviceName ] ]
			break
		default:
			// delegating it to handleAlarmReportUsingAlarmType
			return handleAlarmReportUsingAlarmType(cmd)
	}
	result << createEvent(map)
	result
}

/**
 * Responsible for handling Emergency AlarmReport command
 *
 * @param cmd: The AlarmReport command to be parsed
 *
 * @return The event(s) to be sent out
 */
private def handleEmergencyAlarmReport(cmd) {
	log.trace "[DTH] Executing 'handleEmergencyAlarmReport' with cmd = $cmd"
	def result = []
	def deviceName = device.displayName
	def map = null
	switch(cmd.zwaveAlarmEvent) {
		case 0x01:
			map = [ descriptionText: "Contact police" ]
			break
		case 0x02:
			map = [ descriptionText: "Contact fire service" ]
			break
		default:
			// delegating it to handleAlarmReportUsingAlarmType
			return handleAlarmReportUsingAlarmType(cmd)
	}
	result << createEvent(map)
	result
}

/**
 * Responsible for handling AlarmReport commands which are ignored by Access & Burglar handlers
 *
 * @param cmd: The AlarmReport command to be parsed
 *
 * @return The event(s) to be sent out
 *
 */
private def handleAlarmReportUsingAlarmType(cmd) {
	log.trace "[DTH] Executing 'handleAlarmReportUsingAlarmType' with cmd = $cmd"
	def result = []
	def map = null
	def codeID, lockCodes, codeName
	def deviceName = device.displayName
	lockCodes = loadLockCodes()
	switch(cmd.alarmType) {
		case 10: // IDLock fire sensor
			if (cmd.zwaveAlarmEvent == 2) {
				activateSmoke("Detected Fire")
				runIn(60, deactivateSmoke)
			}
			break
		case 9: // Yale
		case 17:
			map = [ name: "lock", value: "unknown", descriptionText: "Unknown state" ]
			break
		case 16: // Note: for levers this means it's unlocked, for non-motorized deadbolt, it's just unsecured and might not get unlocked
            // Note: Schlage FE599 non motorized deadbolt sends 16 and motorized deadbolts like BE469 send 19. However with non motorized deadbolts it only unsecures the handles and not unlocks, so we need to send a lock event after a few seconds
			if(isSchlageLock() && ("634B" == zwaveInfo.prod && "504C" == zwaveInfo.model)) {
            	log.trace "Non motorized bolt, resetting unlocked to locked notification in 3 seconds"
				runIn(3, reLocked) // The bolt resecures after 3 seconds, send the locked event notification
            }
		case 19: // Unlocked with keypad
			map = [ name: "lock", value: "unlocked" ]
			if (cmd.alarmLevel != null) {
				codeID = readCodeSlotId(cmd)
				codeName = getCodeName(lockCodes, codeID)
				map.descriptionText = "Unlocked by \"$codeName\""
				map.data = [ usedCode: codeID, codeName: codeName, method: "keypad" ]
			} else { 
				map.descriptionText = "Unlocked manually"
				map.data = [ method: "keypad" ]
			}
			break
		case 18: // Locked with keypad
			codeID = readCodeSlotId(cmd)
			map = [ name: "lock", value: "locked" ]
			// Kwikset and Schlage lock reporting code id as 0 when locked using the lock keypad button
			if ((isKwiksetLock() || isSchlageLock()) && codeID == 0) {
				map.descriptionText = "Locked manually"
				map.data = [ method: "keypad" ]
			} else {
				codeName = getCodeName(lockCodes, codeID)
				map.descriptionText = "Locked by \"$codeName\""
				map.data = [ usedCode: codeID, codeName: codeName, method: "keypad" ]
			}
			break
		case 21: // Manually locked, One touch locked via keypad (Yale) alarmLevel 2, using key/knob alarmLevel 1
			map = [ name: "lock", value: "locked", data: [ method: (cmd.alarmLevel == 2) ? "keypad" : "manual" ] ]
			map.descriptionText = "Locked manually"
			break
		case 22: // Manually unlocked
			map = [ name: "lock", value: "unlocked", data: [ method: "manual" ] ]
			map.descriptionText = "Unlocked manually"
			break
		case 23:
			map = [ name: "lock", value: "unknown", descriptionText: "Unknown state" ]
			map.data = [ method: "command" ]
			break
		case 24: // Locked by command (Kwikset/Yale)
			map = [ name: "lock", value: "locked", data: [ method: "command" ] ]
			map.descriptionText = "Locked"
			break
		case 25: // Unlocked by command (Kwikset/Yale)
			map = [ name: "lock", value: "unlocked", data: [ method: "command" ] ]
			map.descriptionText = "Unlocked"
			break
		case 26:
			map = [ name: "lock", value: "unknown", descriptionText: "Unknown state" ]
			map.data = [ method: "auto" ]
			break
		case 27: // Auto locked
			map = [ name: "lock", value: "locked", data: [ method: "auto" ] ]
			map.descriptionText = "Auto locked"
			break
		case 32: // All user codes deleted
			result = allCodesDeletedEvent()
			map = [ name: "codeChanged", value: "all deleted", descriptionText: "Deleted all user codes", isStateChange: true ]
			map.data = [notify: true, notificationText: "Deleted all user codes in $deviceName at ${location.name}"]
			result << createEvent(name: "lockCodes", value: util.toJson([:]), displayed: false, descriptionText: "'lockCodes' attribute updated")
			break
		case 33: // User code deleted
			codeID = readCodeSlotId(cmd)
			if (lockCodes[codeID.toString()]) {
				codeName = getCodeName(lockCodes, codeID)
				map = [ name: "codeChanged", value: "$codeID deleted", isStateChange: true ]
				map.descriptionText = "Deleted \"$codeName\""
				map.data = [ codeName: codeName, notify: true, notificationText: "Deleted \"$codeName\" in $deviceName at ${location.name}" ]
				result << codeDeletedEvent(lockCodes, codeID)
			}
			break
		case 38: // Yale Non Access User (programmed but does not operate lock), alarmLevel represents user slot no
			map = [ name: "invalidCode", value: "detected", descriptionText: "A Non Access User $cmd.alarmLevel was entered at the lock", isStateChange: true, displayed: true ]
			break
		case 43: // Yale DPS
			if (cmd.alarmLevel == 2) {
				setState("open", "$device.displayName is open")
				map = [ descriptionText: "DPS Open", displayed: false ]
			}
			break
		case 13:
		case 112: // Master or user code changed/set
			codeID = readCodeSlotId(cmd)
			if(codeID == 0 && isKwiksetLock()) {
				//Ignoring this AlarmReport as Kwikset reports codeID 0 when all slots are full and user tries to set another lock code manually
				//Kwikset locks don't send AlarmReport when Master code is set
				log.trace "Ignoring this alarm report in case of Kwikset locks"
				break
			}
			codeName = getCodeNameFromState(lockCodes, codeID)
			def changeType = getChangeType(lockCodes, codeID)
			map = [ name: "codeChanged", value: "$codeID $changeType", descriptionText:
				"${getStatusForDescription(changeType)} \"$codeName\"", isStateChange: true ]
			map.data = [ codeName: codeName, notify: true, notificationText: "${getStatusForDescription(changeType)} \"$codeName\" in $deviceName at ${location.name}" ]
			if(!isMasterCode(codeID)) {
				result << codeSetEvent(lockCodes, codeID, codeName)
			} else {
				map.descriptionText = "${getStatusForDescription('set')} \"$codeName\""
				map.data.notificationText = "${getStatusForDescription('set')} \"$codeName\" in $deviceName at ${location.name}"
			}
			break
		case 34:
		case 113: // Duplicate Pin-code error
			codeID = readCodeSlotId(cmd)
			clearStateForSlot(codeID)
			map = [ name: "codeChanged", value: "$codeID failed", descriptionText: "User code is duplicate and not added",
				isStateChange: true, data: [isCodeDuplicate: true] ]
			break
		case 130:  // Batteries replaced (Yale YRD)
			map = [ descriptionText: "Batteries replaced", isStateChange: true ]
			break
		case 131: // Disabled user entered at keypad
			map = [ name: "invalidCode", value: "detected", descriptionText: "Disabled code ${cmd.alarmLevel} was entered", isStateChange: true, displayed: true ]
			break
		case 132: // Yale Out of schedule user (valid)
			map = [ name: "invalidCode", value: "detected", descriptionText: "Out of Schedule code $cmd.alarmLevel was entered", isStateChange: true, displayed: true ]
			break
		case 144: // Yale unlocked using RFID tag
			map = [ name: "lock", value: "unlocked" ]
			if (cmd.alarmLevel > 0) {
				codeID = cmd.alarmLevel
				codeName = getCodeName(lockCodes, codeID)
				map.descriptionText = "Unlocked by \"$codeName\""
				map.data = [ usedCode: codeID, codeName: codeName, method: "rfid" ]
			} else {
				map.descriptionText = "Unlocked manually"
				map.data = [ method: "rfid" ]
			}
			break
		case 96: // Schlage FE599 (alarmType 96, alarmLevel 255)
		case 161: // Tamper Alarm
			if (cmd.alarmLevel == 2) {
				map = [ name: "tamper", value: "detected", descriptionText: "Front escutcheon removed", isStateChange: true ]
				activateMotion("$device.displayName: Door tampering activity detected")
				runIn(60, deactivateMotion) // Clear motion and tamper after 60 seconds, since tamper clear is never sent by a lock
			} else if (cmd.alarmLevel == 1) {
				map = [ name: "invalidCode", value: "detected", descriptionText: "Keypad attempts exceed code entry limit", isStateChange: true, displayed: true ]
			} else if (cmd.alarmLevel == 3) {
				map = [ name: "tamper", value: "detected", descriptionText: "Handle open detected", isStateChange: true, displayed: true ] // Yale 6th gen Keyfree lock Handle Alarm
				activateMotion("$device.displayName: Door tampering activity detected")
				runIn(60, deactivateMotion) // Clear motion and tamper after 60 seconds, since tamper clear is never sent by a lock
			} else {
				map = [ name: "invalidCode", value: "detected", descriptionText: "Detected failed user code attempt", isStateChange: true, displayed: true ]
			}
			break
		case 167: // Low Battery Alarm
			if (!state.lastbatt || now() - state.lastbatt > 12*60*60*1000) {
				map = [ descriptionText: "Battery low", isStateChange: true ]
				result << response(getBatteryState())
			} else {
				map = [ name: "battery", value: device.currentValue("battery"), descriptionText: "Battery low", isStateChange: true ]
			}
			runIn(5, updateTiles) // Update the alarm status on the tiles after 5 seconds giving it time to register			
			break
		case 168: // Critical Battery Alarms
			map = [ name: "battery", value: 1, descriptionText: "Battery level critical", displayed: true ]
			runIn(5, updateTiles) // Update the alarm status on the tiles after 5 seconds giving it time to register			
			break
		case 169: // Battery too low to operate
			map = [ name: "battery", value: 0, descriptionText: "Battery too low to operate lock", isStateChange: true, displayed: true ]
			runIn(5, updateTiles) // Update the alarm status on the tiles after 5 seconds giving it time to register			
			break
		case 176: // Yale Mobile Access, unlocked via Bluetooth
			map = [ name: "lock", value: "unlocked" ]
			map.descriptionText = "Unlocked"
			map.data = [ method: "bluetooth" ]
			break
        case 178: // Yale configuration params updated via Mobile
        	map = [ descriptionText: "Configuration params update via Mobile", displayed: false ]
        	break
		default:
			map = [ displayed: false, descriptionText: "Alarm event ${cmd.alarmType} level ${cmd.alarmLevel}" ]
			break
	}
	
	if (map) {
		if (map.data) {
			map.data.lockName = deviceName
		} else {
			map.data = [ lockName: deviceName ]
		}
		result << createEvent(map)
	}
	result = result.flatten()
	result
}

/**
 * Responsible for parsing UserCodeReport command
 *
 * @param cmd: The UserCodeReport command to be parsed
 *
 * @return The event(s) to be sent out
 *
 */
def zwaveEvent(UserCodeReport cmd) {
	log.trace "[DTH] Executing 'zwaveEvent(UserCodeReport)' with userIdentifier: ${cmd.userIdentifier} and status: ${cmd.userIdStatus}"
	def result = []
	// cmd.userIdentifier seems to be an int primitive type
	def codeID = cmd.userIdentifier.toString()
	def lockCodes = loadLockCodes()
	def map = [ name: "codeChanged", isStateChange: true ]
	def deviceName = device.displayName
	def userIdStatus = cmd.userIdStatus
	
	if (userIdStatus == UserCodeReport.USER_ID_STATUS_OCCUPIED ||
				(userIdStatus == UserCodeReport.USER_ID_STATUS_STATUS_NOT_AVAILABLE && cmd.user)) {
				
		def codeName
		
		// Schlage locks sends a blank/empty code during code creation/updation where as it sends "**********" during scanning
		// Some Schlage locks send "**********" during code creation also. The state check will work for them
		if ((!cmd.code || state["setname$codeID"]) && isSchlageLock()) {
			// this will be executed when the user tries to create/update a user code through the
			// smart app or manually on the lock. This is specific to Schlage locks.
			log.trace "[DTH] User code creation successful for Schlage lock"
			codeName = getCodeNameFromState(lockCodes, codeID)
			def changeType = getChangeType(lockCodes, codeID)

			map.value = "$codeID $changeType"
			map.isStateChange = true
			map.descriptionText = "${getStatusForDescription(changeType)} \"$codeName\""
			map.data = [ codeName: codeName, lockName: deviceName, notify: true, notificationText: "${getStatusForDescription(changeType)} \"$codeName\" in $deviceName at ${location.name}" ]
			if(!isMasterCode(codeID)) {
				result << codeSetEvent(lockCodes, codeID, codeName)
			} else {
				map.descriptionText = "${getStatusForDescription('set')} \"$codeName\""
				map.data.notificationText = "${getStatusForDescription('set')} \"$codeName\" in $deviceName at ${location.name}"
				map.data.lockName = deviceName
			}
		} else {
			// We'll land here during scanning of codes
			codeName = getCodeName(lockCodes, codeID)
			def changeType = getChangeType(lockCodes, codeID)
			if (!lockCodes[codeID]) {
				result << codeSetEvent(lockCodes, codeID, codeName)
			} else {
				map.displayed = false
			}
			map.value = "$codeID $changeType"
			map.descriptionText = "${getStatusForDescription(changeType)} \"$codeName\""
			map.data = [ codeName: codeName, lockName: deviceName ]
		}
	} else if(userIdStatus == 254 && isSchlageLock()) {
		// This is code creation/updation error for Schlage locks.
		// It should be OK to mark this as duplicate pin code error since in case the batteries are down, or lock is not in range,
		// or wireless interference is there, the UserCodeReport will anyway not be received.
		map = [ name: "codeChanged", value: "$codeID failed", descriptionText: "User code is not added", isStateChange: true,
			data: [ lockName: deviceName, isCodeDuplicate: true] ]
	} else {
		// We are using userIdStatus here because codeID = 0 is reported when user tries to set programming code as the user code
		if (codeID == "0" && userIdStatus == UserCodeReport.USER_ID_STATUS_AVAILABLE_NOT_SET && isSchlageLock()) {
			// all codes deleted for Schlage locks
			log.trace "[DTH] All user codes deleted for Schlage lock"
			result << allCodesDeletedEvent()
			map = [ name: "codeChanged", value: "all deleted", descriptionText: "Deleted all user codes", isStateChange: true,
				data: [ lockName: deviceName, notify: true,
					notificationText: "Deleted all user codes in $deviceName at ${location.name}"] ]
			lockCodes = [:]
			result << lockCodesEvent(lockCodes)
		} else {
			// code is not set
			if (lockCodes[codeID]) {
				def codeName = getCodeName(lockCodes, codeID)
				map.value = "$codeID deleted"
				map.descriptionText = "Deleted \"$codeName\""
				map.data = [ codeName: codeName, lockName: deviceName, notify: true, notificationText: "Deleted \"$codeName\" in $deviceName at ${location.name}" ]
				result << codeDeletedEvent(lockCodes, codeID)
			} else {
				map.value = "$codeID unset"
				map.displayed = false
				map.data = [ lockName: deviceName ]
			}
		}
	}
	
	clearStateForSlot(codeID)
	result << createEvent(map)
	
	if (codeID.toInteger() == state.checkCode) {  // reloadAllCodes() was called, keep requesting the codes in order
		if (state.checkCode + 1 > state.codes || state.checkCode >= 8) {
			state.remove("checkCode")  // done
			state["checkCode"] = null
			sendEvent(name: "scanCodes", value: "Complete", descriptionText: "Code scan completed", displayed: false)
		} else {
			state.checkCode = state.checkCode + 1  // get next
			result << response(requestCode(state.checkCode))
		}
	}
	if (codeID == state.pollCode) {
		if (state.pollCode + 1 > state.codes || state.pollCode >= 15) {
			state.remove("pollCode")  // done
			state["pollCode"] = null
		} else {
			state.pollCode = state.pollCode + 1
		}
	}

	result = result.flatten()
	result
}

/**
 * Responsible for parsing UsersNumberReport command
 *
 * @param cmd: The UsersNumberReport command to be parsed
 *
 * @return The event(s) to be sent out
 *
 */
def zwaveEvent(UsersNumberReport cmd) {
	log.trace "[DTH] Executing 'zwaveEvent(UsersNumberReport)' with cmd = $cmd"
	def result = [createEvent(name: "maxCodes", value: cmd.supportedUsers, displayed: false)]
	state.codes = cmd.supportedUsers
	if (state.checkCode) {
		if (state.checkCode <= cmd.supportedUsers) {
			result << response(requestCode(state.checkCode))
		} else {
			state.remove("checkCode")
			state["checkCode"] = null
		}
	}
	result
}

/**
 * Responsible for parsing AssociationReport command
 *
 * @param cmd: The AssociationReport command to be parsed
 *
 * @return The event(s) to be sent out
 *
 */
def zwaveEvent(physicalgraph.zwave.commands.associationv2.AssociationReport cmd) {
	log.trace "[DTH] Executing 'zwaveEvent(physicalgraph.zwave.commands.associationv2.AssociationReport)' with cmd = $cmd"
	def result = []
	if (cmd.nodeId.any { it == zwaveHubNodeId }) {
		state.remove("associationQuery")
		state["associationQuery"] = null
		result << createEvent(descriptionText: "Is associated")
		state.assoc = zwaveHubNodeId
		if (cmd.groupingIdentifier == 2) {
			result << response(zwave.associationV1.associationRemove(groupingIdentifier:1, nodeId:zwaveHubNodeId))
		}
	} else if (cmd.groupingIdentifier == 1) {
		result << response(secure(zwave.associationV1.associationSet(groupingIdentifier:1, nodeId:zwaveHubNodeId)))
	} else if (cmd.groupingIdentifier == 2) {
		result << response(zwave.associationV1.associationSet(groupingIdentifier:2, nodeId:zwaveHubNodeId))
	}
	result
}

/**
 * Responsible for parsing TimeGet command
 *
 * @param cmd: The TimeGet command to be parsed
 *
 * @return The event(s) to be sent out
 *
 */
def zwaveEvent(physicalgraph.zwave.commands.timev1.TimeGet cmd) {
	log.trace "[DTH] Executing 'zwaveEvent(physicalgraph.zwave.commands.timev1.TimeGet)' with cmd = $cmd"
	def result = []
	def now = new Date().toCalendar()
	if(location.timeZone) now.timeZone = location.timeZone
	result << createEvent(descriptionText: "Requested time update", displayed: false)
	result << response(secure(zwave.timeV1.timeReport(
		hourLocalTime: now.get(Calendar.HOUR_OF_DAY),
		minuteLocalTime: now.get(Calendar.MINUTE),
		secondLocalTime: now.get(Calendar.SECOND)))
	)
	result
}

/**
 * Responsible for parsing BasicSet command
 *
 * @param cmd: The BasicSet command to be parsed
 *
 * @return The event(s) to be sent out
 *
 */
def zwaveEvent(physicalgraph.zwave.commands.basicv1.BasicSet cmd) {
	log.trace "[DTH] Executing 'zwaveEvent(physicalgraph.zwave.commands.basicv1.BasicSet)' with cmd = $cmd"
	// The old Schlage locks use group 1 for basic control - we don't want that, so unsubscribe from group 1
	def result = [ createEvent(name: "lock", value: cmd.value ? "unlocked" : "locked") ]
	def cmds = [
			zwave.associationV1.associationRemove(groupingIdentifier:1, nodeId:zwaveHubNodeId).format(),
			"delay 1200",
			zwave.associationV1.associationGet(groupingIdentifier:2).format()
	]
	[result, response(cmds)]
}

/**
 * Responsible for parsing BatteryReport command
 *
 * @param cmd: The BatteryReport command to be parsed
 *
 * @return The event(s) to be sent out
 *
 */
def zwaveEvent(physicalgraph.zwave.commands.batteryv1.BatteryReport cmd) {
	log.trace "[DTH] Executing 'zwaveEvent(physicalgraph.zwave.commands.batteryv1.BatteryReport)' with cmd = $cmd"
	def map = [ name: "battery", unit: "%" ]
	if (cmd.batteryLevel == 0xFF) {
		map.value = 1
		map.descriptionText = "Has a low battery"
	} else {
		map.value = cmd.batteryLevel
		map.descriptionText = "Battery is at ${cmd.batteryLevel}%"
	}
	state.lastbatt = now()
	runIn(5, updateTiles) // Update the alarm status on the tiles after 5 seconds giving it time to register
	log.info "Battery level $map.value%"
	createEvent(map) 
}

/**
 * Responsible for parsing ManufacturerSpecificReport command
 *
 * @param cmd: The ManufacturerSpecificReport command to be parsed
 *
 * @return The event(s) to be sent out
 *
 */
def zwaveEvent(physicalgraph.zwave.commands.manufacturerspecificv2.ManufacturerSpecificReport cmd) {
	log.trace "[DTH] Executing 'zwaveEvent(physicalgraph.zwave.commands.manufacturerspecificv2.ManufacturerSpecificReport)' with cmd = $cmd"
	def result = []
	def msr = String.format("%04X-%04X-%04X", cmd.manufacturerId, cmd.productTypeId, cmd.productId)
	updateDataValue("MSR", msr)
	result << createEvent(descriptionText: "MSR: $msr", isStateChange: false)
	result
}

/**
 * Responsible for parsing VersionReport command
 *
 * @param cmd: The VersionReport command to be parsed
 *
 * @return The event(s) to be sent out
 *
 */
def zwaveEvent(physicalgraph.zwave.commands.versionv1.VersionReport cmd) {
	log.trace "[DTH] Executing 'zwaveEvent(physicalgraph.zwave.commands.versionv1.VersionReport)' with cmd = $cmd"
	def fw = "${cmd.applicationVersion}.${cmd.applicationSubVersion}"
	updateDataValue("fw", fw)
	if (getDataValue("MSR") == "003B-6341-5044") {
		updateDataValue("ver", "${cmd.applicationVersion >> 4}.${cmd.applicationVersion & 0xF}")
	}
	def text = "${device.displayName}: firmware version: $fw, Z-Wave version: ${cmd.zWaveProtocolVersion}.${cmd.zWaveProtocolSubVersion}"
	createEvent(descriptionText: text, isStateChange: false)
}

/**
 * Responsible for parsing ApplicationBusy command
 *
 * @param cmd: The ApplicationBusy command to be parsed
 *
 * @return The event(s) to be sent out
 *
 */
def zwaveEvent(physicalgraph.zwave.commands.applicationstatusv1.ApplicationBusy cmd) {
	log.trace "[DTH] Executing 'zwaveEvent(physicalgraph.zwave.commands.applicationstatusv1.ApplicationBusy)' with cmd = $cmd"
	def msg = cmd.status == 0 ? "try again later" :
			  cmd.status == 1 ? "try again in ${cmd.waitTime} seconds" :
			  cmd.status == 2 ? "request queued" : "sorry"
	createEvent(displayed: true, descriptionText: "Is busy, $msg")
}

/**
 * Responsible for parsing ApplicationRejectedRequest command
 *
 * @param cmd: The ApplicationRejectedRequest command to be parsed
 *
 * @return The event(s) to be sent out
 *
 */
def zwaveEvent(physicalgraph.zwave.commands.applicationstatusv1.ApplicationRejectedRequest cmd) {
	log.trace "[DTH] Executing 'zwaveEvent(physicalgraph.zwave.commands.applicationstatusv1.ApplicationRejectedRequest)' with cmd = $cmd"
	createEvent(displayed: true, descriptionText: "Rejected the last request")
}

/**
 * Responsible for parsing zwave command
 *
 * @param cmd: The zwave command to be parsed
 *
 * @return The event(s) to be sent out
 *
 */
def zwaveEvent(physicalgraph.zwave.Command cmd) {
	log.warn "Unexcepted command from $device.displayName: $cmd"
	log.trace "[DTH] Executing 'zwaveEvent(physicalgraph.zwave.Command)' with cmd = $cmd"
	createEvent(displayed: false, descriptionText: "$cmd")
}

/**
 * Executes lock and then check command with a delay on a lock
 */
def lockAndCheck(doorLockMode) {
	secureSequence([
		zwave.doorLockV1.doorLockOperationSet(doorLockMode: doorLockMode),
		zwave.doorLockV1.doorLockOperationGet()
	], 4200)
}

/**
 * Executes lock command on a lock
 */
def lock() {
	log.trace "[DTH] Executing lock() for device ${device.displayName}"
	lockAndCheck(DoorLockOperationSet.DOOR_LOCK_MODE_DOOR_SECURED)
}

/**
 * Executes unlock command on a lock
 */
def unlock() {
	log.trace "[DTH] Executing unlock() for device ${device.displayName}"
	lockAndCheck(DoorLockOperationSet.DOOR_LOCK_MODE_DOOR_UNSECURED)
}

/**
 * Executes unlock with timeout command on a lock
 */
def unlockWithTimeout() {
	log.trace "[DTH] Executing unlockWithTimeout() for device ${device.displayName}"
	lockAndCheck(DoorLockOperationSet.DOOR_LOCK_MODE_DOOR_UNSECURED_WITH_TIMEOUT)
}

/**
 * PING is used by Device-Watch in attempt to reach the Device
 */
def ping() {
	log.trace "[DTH] Executing ping() for device ${device.displayName}"
	runIn(30, followupStateCheck)
	secure(zwave.doorLockV1.doorLockOperationGet())
}

/**
 * Checks the door lock state. Also, schedules checking of door lock state every one hour.
 */
def followupStateCheck() {
	runEvery1Hour(stateCheck)
	stateCheck()
}

/**
 * Checks the door lock state
 */
def stateCheck() {
	sendHubCommand(new physicalgraph.device.HubAction(secure(zwave.doorLockV1.doorLockOperationGet())))
}

/**
 * Called when the user taps on the refresh button
 */
def refresh() {
    log.debug "Refresh called, Device MSR is $state.MSR"
    identifyLockModel()

    sendEvent([name: "codeVersion", value: clientVersion()]) // Save client version for parent app
    sendEvent([name: "dhName", value: "Universal Z-Wave Lock Device Handler"]) // Save DH Name for parent app

    if (!device.currentValue("checkInterval")) { // If the user updated the device handler
        sendEvent(name: "checkInterval", value: 1 * 60 * 60, displayed: false, data: [protocol: "zwave", hubHardwareId: device.hub.hardwareID, offlinePingable: "1"])
    }
    if (!device.currentValue("motion")?.trim() || !device.currentValue("tamper")?.trim()) { // If the tamper/motion sensor state isn't defined then lets define it to report it correctly in SHM
        resetMotion()
    }
    if (!device.currentValue("smoke")?.trim()) { // If the smoke/fire sensor state isn't defined then lets define it to report it correctly in SHM
        resetSmoke()
    }
    if (!device.currentValue("contact")?.trim()) { // If the door closed sensor state isn't defined then lets define it to report it correctly in SHM
        resetState()
    }

    def cmds = []

	if (!state.associationQuery) {
		cmds << zwave.associationV1.associationGet(groupingIdentifier:2).format()  // old Schlage locks use group 2 and don't secure the Association CC
		cmds << secure(zwave.associationV1.associationGet(groupingIdentifier:1))
		cmds << "delay 4200"
		state.associationQuery = now()
	} else if (now() - state.associationQuery.toLong() > 9000) {
		cmds << zwave.associationV1.associationSet(groupingIdentifier:2, nodeId:zwaveHubNodeId).format()
		cmds << secure(zwave.associationV1.associationSet(groupingIdentifier:1, nodeId:zwaveHubNodeId))
		cmds << zwave.associationV1.associationGet(groupingIdentifier:2).format()
		cmds << secure(zwave.associationV1.associationGet(groupingIdentifier:1))
		cmds << "delay 6000"
		state.associationQuery = now()
	}

    if (!state.MSR || !state.configured) { // If we don't have a MSR or we refreshed the settings, first get it
        log.debug "Getting Device MSR"
        cmds << zwave.manufacturerSpecificV2.manufacturerSpecificGet().format() // Some locks only support non secure responses (Schlage)
        cmds << "delay 4200"
        cmds << secure(zwave.manufacturerSpecificV2.manufacturerSpecificGet()) // Some locks only support secure responses (August Pro)
        cmds << "delay 4200"
    }

    if (!state.configured) {
        cmds << configureLock() // Configure lock settings
        state.configured = true // We're done here
    }

    if (!device.currentValue("scanCodes")) { // Start reloading codes only if initialized for the first time
        cmds << reloadAllCodes()
   	    cmds << "delay 4200"
    }
	if (!device.currentValue("maxCodes")) {
		state.pollCode = 1
		cmds << secure(zwave.userCodeV1.usersNumberGet())
   	    cmds << "delay 4200"
	} else if (state.pollCode && state.pollCode <= state.codes) {
		cmds << requestCode(state.pollCode)
   	    cmds << "delay 4200"
	}
	log.trace "Current user pin code length ${device.currentValue("codeLength")}"
    cmds << getCodeLength() // Pin code length, Check for changes
    cmds << "delay 4200"

    cmds << getAlarmLevel() // Alarm Level
    cmds << "delay 4200"
    cmds << getKeypadState() // Keypad
    cmds << "delay 4200"
    cmds << getSensitiveLevel() // Alarm Sensitivity Level (give alarm 10 seconds to update before getting sensitive)
    cmds << "delay 4200"
    cmds << getAutolockState() // Auto Lock
    cmds << "delay 4200"
    cmds << getOneTouchLockState() // One touch lock
    cmds << "delay 4200"
    cmds << getAudioState() // Audio/Beeper
    cmds << "delay 4200"

    cmds << secure(zwave.doorLockV1.doorLockOperationGet())
    cmds << "delay 4200"
    cmds << getBatteryState() // Battery
    cmds << "delay 4200"

    if (!state.fw) {
        cmds << zwave.versionV1.versionGet().format()
        cmds << "delay 4200"
    }

    //log.trace "refresh sending ${cmds.inspect()}"
    cmds
}

/**
 * Called by the Smart Things platform in case Polling capability is added to the device type
 */
def poll() {
    sendEvent([name: "codeVersion", value: clientVersion()]) // Save client version for parent app
    sendEvent([name: "dhName", value: "Universal Z-Wave Lock Device Handler"]) // Save DH Name for parent app

    if (!device.currentValue("checkInterval")) { // If the user updated the device handler
        sendEvent(name: "checkInterval", value: 1 * 60 * 60, displayed: false, data: [protocol: "zwave", hubHardwareId: device.hub.hardwareID, offlinePingable: "1"])
    }

    if (!device.currentValue("motion")?.trim() || !device.currentValue("tamper")?.trim()) { // If the tamper/motion sensor state isn't defined then lets define it to report it correctly in SHM
        resetMotion()
    }
    if (!device.currentValue("smoke")?.trim()) { // If the smoke/fire sensor state isn't defined then lets define it to report it correctly in SHM
        resetSmoke()
    }
    if (!device.currentValue("contact")?.trim()) { // If the door closed sensor state isn't defined then lets define it to report it correctly in SHM
        resetState()
    }

    def cmds = []

    log.debug "Poll called, Device MSR is $state.MSR"
    if (!state.MSR) { // If we don't have a MSR, first get it (and wait for it to complete)
        log.debug "Getting Device MSR"
        cmds << zwave.manufacturerSpecificV2.manufacturerSpecificGet().format() // Some locks only support non secure responses (Schlage)
        cmds << "delay 4200"
        cmds << secure(zwave.manufacturerSpecificV2.manufacturerSpecificGet()) // Some locks only support secure responses (August Pro)
        cmds << "delay 4200"
    }

    // Only check lock state if it changed recently or we haven't had an update in an hour
    def latest = device.currentState("lock")?.date?.time
    if (state.assoc != zwaveHubNodeId && secondsPast(state.associationQuery, 19 * 60)) {
		cmds << zwave.associationV1.associationSet(groupingIdentifier:2, nodeId:zwaveHubNodeId).format()
		cmds << secure(zwave.associationV1.associationSet(groupingIdentifier:1, nodeId:zwaveHubNodeId))
		cmds << zwave.associationV1.associationGet(groupingIdentifier:2).format()
		cmds << "delay 6000"
		cmds << secure(zwave.associationV1.associationGet(groupingIdentifier:1))
		cmds << "delay 6000"
		state.associationQuery = now()
    } else if (!latest || !state.lastPoll || !secondsPast(latest, 6 * 60) || secondsPast(state.lastPoll, 55 * 60)) {
        if (!device.currentValue("scanCodes")) { // Start reloading codes only if initialized for the first time
            cmds << reloadAllCodes()
            cmds << "delay 4200"
        }
		if (!device.currentValue("maxCodes")) {
			state.pollCode = 1
			cmds << secure(zwave.userCodeV1.usersNumberGet())
   	     	cmds << "delay 4200"
		} else if (state.pollCode && state.pollCode <= state.codes) {
			cmds << requestCode(state.pollCode)
   		    cmds << "delay 4200"
		}
		log.trace "Current user pin code length ${device.currentValue("codeLength")}"
        if (device.currentValue("codeLength") != 0) { // If we haven't checked for it (null) or if it was returned by the lock, check for changes
            cmds << getCodeLength() // Pin code length
            cmds << "delay 4200"
        }
        cmds << secure(zwave.doorLockV1.doorLockOperationGet())
        cmds << "delay 4200"
        cmds << getAlarmLevel() // Alarm Level
        cmds << "delay 4200"
        cmds << getKeypadState() // Keypad
        cmds << "delay 4200"
        cmds << getSensitiveLevel() // Alarm Sensitivity Level (give alarm 10 seconds to update before getting sensitive)
        cmds << "delay 4200"
        cmds << getAutolockState() // Auto Lock
        cmds << "delay 4200"
        cmds << getOneTouchLockState() // One touch lock
        cmds << "delay 4200"
        cmds << getAudioState() // Audio/Beeper
        cmds << "delay 4200"
        state.lastPoll = now()
    }
	if (!state.fw) {
		cmds << zwave.versionV1.versionGet().format()
        cmds << "delay 4200"
	}
    if (!state.lastbatt || secondsPast(state.lastbatt, 53*60*60)) {
        cmds << getBatteryState()
        cmds << "delay 4200"
        state.lastbatt = now()  //inside-214
    }
    if (cmds) {
        log.debug "poll is sending ${cmds.inspect()}"
        cmds
    } else {
        // workaround to keep polling from stopping due to lack of activity
        log.trace "Poll called again to soon, skipping poll to save battery"
        sendEvent(descriptionText: "skipping poll", isStateChange: true, displayed: false)
        null
    }
}

/**
 * Returns the command for user code get
 *
 * @param codeID: The code slot number
 *
 * @return The command for user code get
 */
def requestCode(codeID) {
	secure(zwave.userCodeV1.userCodeGet(userIdentifier: codeID))
}

/**
 * API endpoint for server smart app to populate the attributes. Called only when the attributes are not populated.
 *
 * @return The command(s) fired for reading attributes
 */
def reloadAllCodes() {
	log.trace "[DTH] Executing 'reloadAllCodes()' by ${device.displayName}"
	sendEvent(name: "scanCodes", value: "Scanning", descriptionText: "Code scan in progress", displayed: false)
	def lockCodes = loadLockCodes()
	sendEvent(lockCodesEvent(lockCodes))
	state.checkCode = state.checkCode ?: 1

	def cmds = []
	// Not calling validateAttributes() here because userNumberGet command will be added twice
	if(device.currentValue("codeLength") != 0) {
		cmds << getCodeLength()
	}
	if (!state.codes) {
		// BUG: There might be a bug where Schlage does not return the below number of codes
		cmds << secure(zwave.userCodeV1.usersNumberGet())
	} else {
		sendEvent(name: "maxCodes", value: state.codes, displayed: false)
		cmds << requestCode(state.checkCode)
	}
	if(cmds.size() > 1) {
		cmds = delayBetween(cmds, 4200)
	}
	cmds
}

/**
 * API endpoint for setting the user code length on a lock. This is specific to Schlage locks.
 *
 * @param length: The user code length
 *
 * @returns The command fired for writing the code length attribute
 */
def setCodeLength(length) {
	if (isSchlageLock()) {
		length = length.toInteger()
		if (length >= schlageParamMap.CodeLength.Min && length <= schlageParamMap.CodeLength.Max) {
			log.trace "[DTH] Executing 'setCodeLength()' by ${device.displayName}"
			def val = []
			val << length
			return secure(zwave.configurationV1.configurationSet(parameterNumber: schlageParamMap.CodeLength.Param, size: schlageParamMap.CodeLength.Size, configurationValue: val))
		}
	}
	return null
}

/**
 * API endpoint for getting the user code length on a lock.
 *
 * @returns The command fired for getting the code length attribute or if it isn't supported sets the value of attribute 'codeLength' to 0 and returns null
 */
def getCodeLength() {
    log.debug "Getting configured user pin code length"

    def parameter
    def security = true
    if (isSchlageLock()) { // Schlage lock
        parameter = schlageParamMap.CodeLength.Param
        switch (state.MSR) { // check if we have a supported device
            // First do specific cases before moving to generic cases with regex matching
            case ~/003B-634B-.*/: // Schlage FE5xx/BE3xx
                log.info "Found Schlage FE5xx/BE3xx, fixed pin length 4 digits"
                sendEvent(name: "codeLength", value: 4, descriptionText: "Pin code length") // Fixed length 4 digits for these locks
                return null // we're done here no command to send, it's fixed length for these locks
                break

            default:
                log.trace "Querying Schlage pin length"
                break
        }
    } else if (isYaleLock()) {
        log.info "Found Yale, 4-8 digit pin lengths"
        sendEvent(name: "maxPINLength", value: 8, descriptionText: "Max pin code length")
        sendEvent(name: "minPINLength", value: 4, descriptionText: "Min pin code length")
        return null // we're done here no command to send, it's defined range for these locks
    } else if (isKwiksetLock()) { // Kwikset lock
        log.info "Found Kwikset, 4-8 digit pin lengths"
        sendEvent(name: "maxPINLength", value: 8, descriptionText: "Max pin code length")
        sendEvent(name: "minPINLength", value: 4, descriptionText: "Min pin code length")
        return null // we're done here no command to send, it's defined range for these locks
    } else if (isSamsungLock()) { // Samsung lock
        log.info "Found Samsung, 4-10 digit pin lengths"
        sendEvent(name: "maxPINLength", value: 10, descriptionText: "Max pin code length")
        sendEvent(name: "minPINLength", value: 4, descriptionText: "Min pin code length")
        return null // we're done here no command to send, it's defined range for these locks
    } else if (isIDLock()) { // IDLock lock
        log.info "Found IDLock, 4-10 digit pin lengths"
        sendEvent(name: "maxPINLength", value: 10, descriptionText: "Max pin code length")
        sendEvent(name: "minPINLength", value: 4, descriptionText: "Min pin code length")
        return null // we're done here no command to send, it's defined range for these locks
    } else if (isDanaLockV2()) { // Danalock V2 lock
        log.info "Found DanalockV2, 4-10 digit pin lengths"
        sendEvent(name: "maxPINLength", value: 10, descriptionText: "Max pin code length")
        sendEvent(name: "minPINLength", value: 4, descriptionText: "Min pin code length")
        return null // we're done here no command to send, it's defined range for these locks
    } else {
        log.warn "Unsupported device with MSR $state.MSR, cannot query pin length"
        sendEvent(name: "codeLength", value: 0) // Not supported
        return null
    }

    security ? secure(zwave.configurationV1.configurationGet(parameterNumber: parameter)) : zwave.configurationV1.configurationGet(parameterNumber: parameter).format()
}

/**
 * API endpoint for setting a user code on a lock
 *
 * @param codeID: The code slot number
 *
 * @param code: The code PIN
 *
 * @param codeName: The name of the code
 *
 * @returns cmds: The commands fired for creation and checking of a lock code
 */
def setCode(codeID, code, codeName = null) {
	if (!code) {
		log.trace "[DTH] Executing 'nameSlot()' by ${this.device.displayName}"
		nameSlot(codeID, codeName)
		return
	}
	
	log.trace "[DTH] Executing 'setCode()' by ${this.device.displayName}"
	def strcode = code
	if (code instanceof String) {
		code = code.toList().findResults { if(it > ' ' && it != ',' && it != '-') it.toCharacter() as Short }
	} else {
		strcode = code.collect{ it as Character }.join()
	}

	def strname = (codeName ?: "Code $codeID")
	state["setname$codeID"] = strname
	
	def cmds = validateAttributes()
	cmds << secure(zwave.userCodeV1.userCodeSet(userIdentifier:codeID, userIdStatus:1, user:code))
	if(cmds.size() > 1) {
		cmds = delayBetween(cmds, 4200)
	}
	cmds
}

/**
 * Validates attributes and if attributes are not populated, adds the command maps to list of commands
 * @return List of commands or empty list
 */
def validateAttributes() {
	def cmds = []
	if(!device.currentValue("maxCodes")) {
		cmds << secure(zwave.userCodeV1.usersNumberGet())
	}
	if(device.currentValue("codeLength") != 0) {
		cmds << getCodeLength()
	}
	log.trace "validateAttributes returning commands list: " + cmds
	cmds
}

/**
 * API endpoint for setting/deleting multiple user codes on a lock
 *
 * @param codeSettings: The map with code slot numbers and code pins (in case of update)
 *
 * @returns The commands fired for creation and deletion of lock codes
 */
def updateCodes(codeSettings) {
	log.trace "[DTH] Executing updateCodes() for device ${device.displayName}"
	if(codeSettings instanceof String) codeSettings = util.parseJson(codeSettings)
	def set_cmds = []
	codeSettings.each { name, updated ->
		if (name.startsWith("code")) {
			def n = name[4..-1].toInteger()
			if (updated && updated.size() >= 4 && updated.size() <= 8) {
				log.debug "Setting code number $n"
				set_cmds << secure(zwave.userCodeV1.userCodeSet(userIdentifier:n, userIdStatus:1, user:updated))
			} else if (updated == null || updated == "" || updated == "0") {
				log.debug "Deleting code number $n"
				set_cmds << deleteCode(n)
			}
		} else log.warn("unexpected entry $name: $updated")
	}
	if (set_cmds) {
		return response(delayBetween(set_cmds, 2200))
	}
	return null
}

/**
 * Renames an existing lock slot
 *
 * @param codeSlot: The code slot number
 *
 * @param codeName The new name of the code
 */
void nameSlot(codeSlot, codeName) {
	codeSlot = codeSlot.toString()
	if (!isCodeSet(codeSlot)) {
		return
	}
	def deviceName = device.displayName
	log.trace "[DTH] - Executing nameSlot() for device $deviceName"
	def lockCodes = loadLockCodes()
	def oldCodeName = getCodeName(lockCodes, codeSlot)
	def newCodeName = codeName ?: "Code $codeSlot"
	lockCodes[codeSlot] = newCodeName
	sendEvent(lockCodesEvent(lockCodes))
	sendEvent(name: "codeChanged", value: "$codeSlot renamed", data: [ lockName: deviceName, notify: false, notificationText: "Renamed \"$oldCodeName\" to \"$newCodeName\" in $deviceName at ${location.name}" ],
		descriptionText: "Renamed \"$oldCodeName\" to \"$newCodeName\"", displayed: true, isStateChange: true)
}

/**
 * API endpoint for deleting a user code on a lock
 *
 * @param codeID: The code slot number
 *
 * @returns cmds: The command fired for deletion of a lock code
 */
def deleteCode(codeID) {
	log.trace "[DTH] Executing 'deleteCode()' by ${this.device.displayName}"
	// Calling user code get when deleting a code because some Kwikset locks do not generate
	// AlarmReport when a code is deleted manually on the lock
	secureSequence([
		zwave.userCodeV1.userCodeSet(userIdentifier:codeID, userIdStatus:0),
		zwave.userCodeV1.userCodeGet(userIdentifier:codeID)
	], 4200)
}

/**
 * Encapsulates a command
 *
 * @param cmd: The command to be encapsulated
 *
 * @returns ret: The encapsulated command
 */
private secure(physicalgraph.zwave.Command cmd) {
	zwave.securityV1.securityMessageEncapsulation().encapsulate(cmd).format()
}

/**
 * Encapsulates list of command and adds a delay
 *
 * @param commands: The list of command to be encapsulated
 *
 * @param delay: The delay between commands
 *
 * @returns The encapsulated commands
 */
private secureSequence(commands, delay=4200) {
	delayBetween(commands.collect{ secure(it) }, delay)
}

/**
 * Checks if the time elapsed from the provided timestamp is greater than the number of senconds provided
 *
 * @param timestamp: The timestamp
 *
 * @param seconds: The number of seconds
 *
 * @returns true if elapsed time is greater than number of seconds provided, else false
 */
private Boolean secondsPast(timestamp, seconds) {
	if (!(timestamp instanceof Number)) {
		if (timestamp instanceof Date) {
			timestamp = timestamp.time
		} else if ((timestamp instanceof String) && timestamp.isNumber()) {
			timestamp = timestamp.toLong()
		} else {
			return true
		}
	}
	return (now() - timestamp) > (seconds * 1000)
}

/**
 * Reads the code name from the 'lockCodes' map
 *
 * @param lockCodes: map with lock code names
 *
 * @param codeID: The code slot number
 *
 * @returns The code name
 */
private String getCodeName(lockCodes, codeID) {
	if (isMasterCode(codeID)) {
		return "Master Code"
	}
	lockCodes[codeID.toString()] ?: "Code $codeID"
}

/**
 * Reads the code name from the device state
 *
 * @param lockCodes: map with lock code names
 *
 * @param codeID: The code slot number
 *
 * @returns The code name
 */
private String getCodeNameFromState(lockCodes, codeID) {
	if (isMasterCode(codeID)) {
		return "Master Code"
	}
	def nameFromLockCodes = lockCodes[codeID.toString()]
	def nameFromState = state["setname$codeID"]
	if(nameFromLockCodes) {
		if(nameFromState) {
			//Updated from smart app
			return nameFromState
		} else {
			//Updated from lock
			return nameFromLockCodes
		}
	} else if(nameFromState) {
		//Set from smart app
		return nameFromState
	}
	//Set from lock
	return "Code $codeID"
}

/**
 * Check if a user code is present in the 'lockCodes' map
 *
 * @param codeID: The code slot number
 *
 * @returns true if code is present, else false
 */
private Boolean isCodeSet(codeID) {
	// BUG: Needed to add loadLockCodes to resolve null pointer when using schlage?
	def lockCodes = loadLockCodes()
	lockCodes[codeID.toString()] ? true : false
}

/**
 * Reads the 'lockCodes' attribute and parses the same
 *
 * @returns Map: The lockCodes map
 */
private Map loadLockCodes() {
	parseJson(device.currentValue("lockCodes") ?: "{}") ?: [:]
}

/**
 * Populates the 'lockCodes' attribute by calling create event
 *
 * @param lockCodes The user codes in a lock
 */
private Map lockCodesEvent(lockCodes) {
	createEvent(name: "lockCodes", value: util.toJson(lockCodes), displayed: false,
	descriptionText: "'lockCodes' attribute updated")
}

/**
 * Utility function to figure out if code id pertains to master code or not
 *
 * @param codeID - The slot number in which code is set
 * @return - true if slot is for master code, false otherwise
 */
private boolean isMasterCode(codeID) {
	if(codeID instanceof String) {
		codeID = codeID.toInteger()
	}
	(codeID == 0) ? true : false
}

/**
 * Creates the event map for user code creation
 *
 * @param lockCodes: The user codes in a lock
 *
 * @param codeID: The code slot number
 *
 * @param codeName: The name of the user code
 *
 * @return The list of events to be sent out
 */
private def codeSetEvent(lockCodes, codeID, codeName) {
	clearStateForSlot(codeID)
	// codeID seems to be an int primitive type
	lockCodes[codeID.toString()] = (codeName ?: "Code $codeID")
	def result = []
	result << lockCodesEvent(lockCodes)
	def codeReportMap = [ name: "codeReport", value: codeID, data: [ code: "" ], isStateChange: true, displayed: false ]
	codeReportMap.descriptionText = "${device.displayName} code $codeID is set"
	result << createEvent(codeReportMap)
	result
}

/**
 * Creates the event map for user code deletion
 *
 * @param lockCodes: The user codes in a lock
 *
 * @param codeID: The code slot number
 *
 * @return The list of events to be sent out
 */
private def codeDeletedEvent(lockCodes, codeID) {
	lockCodes.remove("$codeID".toString())
	// not sure if the trigger has done this or not
	clearStateForSlot(codeID)
	def result = []
	result << lockCodesEvent(lockCodes)
	def codeReportMap = [ name: "codeReport", value: codeID, data: [ code: "" ], isStateChange: true, displayed: false ]
	codeReportMap.descriptionText = "${device.displayName} code $codeID was deleted"
	result << createEvent(codeReportMap)
	result
}

/**
 * Creates the event map for all user code deletion
 *
 * @return The List of events to be sent out
 */
private def allCodesDeletedEvent() {
	def result = []
	def lockCodes = loadLockCodes()
	def deviceName = device.displayName
	lockCodes.each { id, code ->
		result << createEvent(name: "codeReport", value: id, data: [ code: "" ], descriptionText: "code $id was deleted",
					displayed: false, isStateChange: true)
		
		def codeName = code
		result << createEvent(name: "codeChanged", value: "$id deleted", data: [ codeName: codeName, lockName: deviceName,
			notify: true, notificationText: "Deleted \"$codeName\" in $deviceName at ${location.name}" ],
		descriptionText: "Deleted \"$codeName\"",
		displayed: true, isStateChange: true)
		clearStateForSlot(id)
	}
	result
}

/**
 * Checks if a change type is set or update
 *
 * @param lockCodes: The user codes in a lock
 *
 * @param codeID The code slot number
 *
 * @return "set" or "update" basis the presence of the code id in the lockCodes map
 */
private def getChangeType(lockCodes, codeID) {
	def changeType = "set"
	if (lockCodes[codeID.toString()]) {
		changeType = "changed"
	}
	changeType
}

/**
 * Method to obtain status for descriptuion based on change type
 * @param changeType: Either "set" or "changed"
 * @return "Added" for "set", "Updated" for "changed", "" otherwise
 */
private def getStatusForDescription(changeType) {
	if("set" == changeType) {
		return "Added"
	} else if("changed" == changeType) {
		return "Updated"
	}
	//Don't return null as it cause trouble
	return ""
}

/**
 * Clears the code name and pin from the state basis the code slot number
 *
 * @param codeID: The code slot number
 */
def clearStateForSlot(codeID) {
	state.remove("setname$codeID")
	state["setname$codeID"] = null
}

// CUSTOM STUFF
/**
 * Responsible for parsing ConfigurationReport command
 *
 * @param cmd: The ConfigurationReport command to be parsed
 *
 * @return The event(s) to be sent out
 *
 */
def zwaveEvent(physicalgraph.zwave.commands.configurationv2.ConfigurationReport cmd) { // Even though you're using V1 to read, ST seems to report it using V2 format, so process as V2
    log.trace "ConfigurationReport $cmd"
    def map = []

    if (isSchlageLock()) { // Schlage lock
        map = schlageConfigurationReport(cmd)
    } else if (isYaleLock()) { // Yale lock
        map = yaleConfigurationReport(cmd)
    } else if (isKwiksetLock()) { // Kwikset lock
        map = kwiksetConfigurationReport(cmd)
    } else if (isIDLock()) { // IDLock
        map = idLockConfigurationReport(cmd)
    } else if (isDanaLockV2()) { // Danalock V2
        map = danaLockConfigurationReportV2(cmd)
    } else if (isDanaLockV3()) { // Danalock V3
        map = danaLockConfigurationReportV3(cmd)
    } else if (isSamsungLock()) {
        map = samsungConfigurationReport(cmd)
    } else {
        log.warn "Unknown device with MSR $state.MSR, report it to developer"
        sendEvent(name: "contactDeveloper", value: "Unknown lock. Contact developer, quote MSR $state.MSR", isStateChange: true, displayed: true) // Report to dev with MSR
    }

    runIn(5, updateTiles) // Update the alarm status on the tiles after 5 seconds giving it time to register the new map

    //log.info map
    return map
}

// Parse Samsung lock parameters
private samsungConfigurationReport(cmd) {
    log.trace "Processing Samsung Configuration Report"
    def map = null

    switch (cmd.parameterNumber) {
        case samsungParamMap.PrivacyMode.Param: // Privacy mode enabled -> Keypad disabled and vice versa
            map = [name: "codeunlock", descriptionText: "Keypad"]
            switch (cmd.scaledConfigurationValue) {
                case samsungParamMap.PrivacyMode.Disabled:
                    map.value = "enabled"
                    break

                case samsungParamMap.PrivacyMode.Enabled:
                    map.value = "disabled"
                    break

                default:
                    map.value = "unknown"
                    map.displayed = false
                    break
            }
            break

        default:
            map = [ displayed: false, descriptionText: "$device.displayName: Parameter $cmd.parameterNumber configuration $cmd.configurationValue" ]
            break
    }

    return createEvent(map)
}

// Parse DanaLock V3 parameters
private danaLockConfigurationReportV3(cmd) {
    log.trace "Processing Danalock Configuration Report V3"
    def map = null

    switch (cmd.parameterNumber) {
        case danalockV3ParamMap.TurnAndGo.Param:
            map = [descriptionText: "Twist Assist/Turn And Go: ${cmd.configurationValue[0]}"]
            break

        case danalockV3ParamMap.BrakeAndGo.Param:
            map = [descriptionText: "Hold and Release/Brake And Go: ${getDanalockV3ParamMap(cmd.configurationValue).BrakeAndGo.Value} seconds"]
            break

        case danalockV3ParamMap.Async.Param:
            map = [descriptionText: "Async/Blocked 2 Blocked: ${cmd.configurationValue[0]}"]
            break

        case danalockV3ParamMap.BleTempAllowTimer.Param:
            map = [descriptionText: "Bluetooth Temporary Allow Timer: ${getDanalockV3ParamMap(cmd.configurationValue).BleTempAllowTimer.Value} seconds"]
            break

        case danalockV3ParamMap.BleAlwaysAllowed.Param:
            map = [descriptionText: "Bluetooth Always Allowed: ${cmd.configurationValue[0]}"]
            break

        case danalockV3ParamMap.AutoLock.Param:
            map = [name: "autolock"]
            switch(getDanalockV3ParamMap(cmd.configurationValue).AutoLock.Value) {
                case danalockV3ParamMap.AutoLock.Min:
                    map.value = "disabled"
                    break

                default:
                    map.value = "enabled"
                    map.descriptionText = "Auto Lock ${getDanalockV3ParamMap(cmd.configurationValue).AutoLock.Value} seconds"
                    break
            }
            break

        default:
            map = [ displayed: false, descriptionText: "$device.displayName: Parameter $cmd.parameterNumber configuration $cmd.configurationValue" ]
            break
    }

    return createEvent(map)
}

// Process Danalock V2 parameters
private danaLockConfigurationReportV2(cmd) {
    log.trace "Processing Danalock Configuration Report V2"
    def map = null

    switch (cmd.parameterNumber) {
        case 1:
            map = [descriptionText: "Direction: ${cmd.configurationValue[0]}"]
            break

        case 2:
            map = [descriptionText: "Speed: ${cmd.configurationValue[0]}"]
            break

        case 3:
            map = [descriptionText: "Mode: ${cmd.configurationValue[0]}"]
            break

        case 4:
            map = [descriptionText: "Turn degrees: ${cmd.configurationValue[0]}"]
            break

        case 5:
            // Auto Lock
            map = [name: "autolock"]
            if (cmd.configurationValue[0] > 0) { // Auto lock
                map.value = "enabled"
                map.descriptionText = "Auto Lock ${cmd.configurationValue[0]} seconds"
            } else {
                map.value = "disabled"
            }
            break

        case 6:
        map = [name: "beeper", descriptionText: "Audio Mode"]
            switch (cmd.configurationValue[0]) {
                case 0:
                    map.value = "disabled"
                    break

                case 1:
                    map.value = "enabled"
                    break

                default:
                    map.value = "unknown"
                    map.displayed = false
                    break
            }
            break

        case 7:
            map = [descriptionText: "Battery type: ${cmd.configurationValue[0]}"]
            break

        case 8:
            map = [descriptionText: "Battery alarm level: ${cmd.configurationValue[0]}"]
            break

        case 9:
            map = [descriptionText: "Turn&Go: ${cmd.configurationValue[0]}"]
            break

        case 10:
            map = [descriptionText: "Brake&GoBack: ${cmd.configurationValue[0]} seconds"]
            break

        case 11:
            map = [descriptionText: "Async: ${cmd.configurationValue[0]}"]
            break

        case 12:
            map = [descriptionText: "Door Lock Operation Report type: ${cmd.configurationValue[0]}"]
            break

        default:
            map = [ displayed: false, descriptionText: "$device.displayName: Parameter $cmd.parameterNumber configuration $cmd.configurationValue" ]
        	break
    }

    return createEvent(map)
}

// Parse the IDLock parameters
private idLockConfigurationReport(cmd) {
    log.trace "Processing IDLock Configuration Report"
    def map = null

    switch (cmd.parameterNumber) {
        // Configuration parameter 1 is one byte code
        // Bit 0 Auto Lock Status (1: enable)
        // Bit 1 Away Mode Status (1: enable)
        case 1:
            // Away Mode
            map = [name: "codeunlock", descriptionText: "Keypad"]
            if (cmd.configurationValue[0] & 0x2) { // Away Mode enabled = Keypad disable
                map.value = "disabled"
            } else {
                map.value = "enabled"
            }
            sendEvent(map)

            // Auto Lock
            map = [name: "autolock", descriptionText: "Auto lock"]
            if (cmd.configurationValue[0] & 0x1) { // Auto lock
                map.value = "enabled"
            } else {
                map.value = "disabled"
            }
            break

        default:
            map = [ displayed: false, descriptionText: "$device.displayName: Parameter $cmd.parameterNumber configuration $cmd.configurationValue" ]
	        break
    }

    return createEvent(map)
}

// Parse the Kwikset parameters
private kwiksetConfigurationReport(cmd) {
    log.trace "Processing Kwikset Configuration Report"
    def map = null

    switch (cmd.parameterNumber) {
        // Configuration parameter 31 is one byte read only bit mask field that returns the state of the user accessible Dipswitches on the door lock
        // Bit 0 Lock LED Status (1: enable)
        // Bit 1 Auto lock (1: enable)
        // Bit 2 Auto Buzzer (1: enable)
        // Bit 3 Secure Screen (1: enable) *Only for MB 916
        case 31:
            // Beeper
            map = [name: "beeper", descriptionText: "Auto Buzzer"]
            if (cmd.configurationValue[0] & 0x4) { // Beeper
                map.value = "enabled"
            } else {
                map.value = "disabled"
            }
            sendEvent(map)

            // Auto Lock
            map = [name: "autolock", descriptionText: "Auto lock"]
            if (cmd.configurationValue[0] & 0x2) { // Auto lock
                map.value = "enabled"
            } else {
                map.value = "disabled"
            }
            break

        default:
            map = [ displayed: false, descriptionText: "$device.displayName: Parameter $cmd.parameterNumber configuration $cmd.configurationValue" ]
	        break
    }

    return createEvent(map)
}

// Parse the Yale parameters
private yaleConfigurationReport(cmd) {
    log.trace "Processing Yale Configuration Report"
    def map = null

    switch (cmd.parameterNumber) {
        case 1: // Beeper, Assa Abloy and Yale have it in reverse to each other
        map = [name: "beeper", descriptionText: "Audio Mode"]
        switch (state.MSR) {
            case ~/0129-80.*/: // Commercial
                switch (cmd.configurationValue[0]) {
                    case 1:
                    case 2:
                        map.value = "enabled"
                        break

                    case 3:
                        map.value = "disabled"
                        break

                    default:
                        map.value = "unknown"
                    	map.displayed = false
                    	break
                }
                break
                
            default: // All the rest of Yale
                switch (cmd.configurationValue[0]) {
                    case 1:
	                    map.value = "disabled"
    	                break

                    case 3:
                    case 2:
                        map.value = "enabled"
                        break

                    default:
                        map.value = "unknown"
        	            map.displayed = false
           				break
                }
                break
        }
        break

        case 2: // Auto lock
            map = [name: "autolock", descriptionText: "Auto lock"]
            switch (cmd.configurationValue[0]) {
                case 0:
                    map.value = "disabled"
                    break

                case 0xFF:
                    map.value = "enabled"
                    break

                default:
                    map.value = "unknown"
                    map.displayed = false
                    break
            }
            break

        case 3: // Auto relock time
            map = [descriptionText: "Auto relock time ${cmd.configurationValue[0]} seconds"]
            break

        case 4: // Wrong code entry limit
            map = [descriptionText: "Wrong code entry tamper alert limit ${cmd.configurationValue[0]}"]
            break

        case 5: // Language
            switch (cmd.configurationValue[0]) {
                case 0:
                    map = [descriptionText: "Language English"]
                    break

                case 1:
                    map = [descriptionText: "Language Spanish"]
                    break

                case 2:
                    map = [descriptionText: "Language French"]
                    break

                default:
                    map = [descriptionText: "Language Unknown: ${cmd.configurationValue[0]}"]
                    break
            }
            break

        case 7: // Shutdown time after wrong entries
            map = [descriptionText: "Shutdown time ${cmd.configurationValue[0]} seconds"]
            break

        case 8: // Vacation mode enabled -> Keypad disabled and vice versa
            map = [name: "codeunlock", descriptionText: "Keypad"]
            switch (cmd.configurationValue[0]) {
                case 0:
                    map.value = "enabled"
                    break

                case 1:
                case 2:
                    map.value = "disabled"
                    break

                default:
                    map.value = "unknown"
                    map.displayed = false
                    break
            }
            break

        case 11: // One touch locking
            map = [name: "onetouchlock", descriptionText: "One Touch Locking"]
            switch (cmd.configurationValue[0]) {
                case 0x0:
                    map.value = "disabled"
                    break

                case 0xFF:
                    map.value = "enabled"
                    break

                default:
                    map.value = "unknown"
                    map.displayed = false
                    break
            }
            break

        case 12: // Privacy button
            switch (cmd.configurationValue[0]) {
                case 0x0:
                    map = [descriptionText: "Privacy button off"]
                    break

                case 0xFF:
                    map = [descriptionText: "Privacy button on"]
                    break

                default:
                    map = [descriptionText: "Privacy button unknown: ${cmd.configurationValue[0]}"]
                    break
            }
            break

        case 13: // Lock status LED
            switch (cmd.configurationValue[0]) {
                case 0x0:
                    map = [descriptionText: "Lock status LED off"]
                    break

                case 0xFF:
                    map = [descriptionText: "Lock status LED on"]
                    break

                default:
                    map = [descriptionText: "Lock status LED unknown: ${cmd.configurationValue[0]}"]
                    break
            }
            break

        case 18: // Door propped timer
            map = [descriptionText: "Door propped ${cmd.configurationValue[0]*10} seconds"]
            break

        case 19: // DPS Alarm
            switch (cmd.configurationValue[0]) {
                case 0x0:
                    map = [descriptionText: "Door position sensor state off"]
                    break

                case 0xFF:
                    map = [descriptionText: "Door position sensor state on"]
                    break

                default:
                    map = [descriptionText: "Door position sensor state unknown: ${cmd.configurationValue[0]}"]
                    break
            }
            break

        default:
            map = [ displayed: false, descriptionText: "$device.displayName: Parameter $cmd.parameterNumber configuration $cmd.configurationValue" ]
            break
    }

    return createEvent(map)
}

// Parse the Schlage parameters
private schlageConfigurationReport(cmd) {
    log.trace "Processing Schlage Configuration Report"
    def map = null
    def result = []

    switch (cmd.parameterNumber) {
        case 0x03: // Beeper
            map = [name: "beeper", descriptionText: "Beeper"]
            switch (cmd.configurationValue[0]) {
                case 0:
                    map.value = "disabled"
                    break

                case 0x1:
                    switch (state.MSR) {
                        case ~/003B-634B-.*/: // Schlage FE5xx/BE3xx Series Generic
                            map.value = "enabled"
                            break

                        default:
                            map.value = "unknown"
                            map.displayed = false
                            break
                    }
                    break

                case 0xff:
                    map.value = "enabled"
                    break

                default:
                    map.value = "unknown"
                    map.displayed = false
                    break
            }
            break

        case 0x04: // Vacation mode enabled -> Keypad disabled and vice versa
            map = [name: "codeunlock", descriptionText: "Keypad"]
            switch (cmd.configurationValue[0]) {
                case 0:
                    map.value = "enabled"
                    break

                case 0x1:
                    switch (state.MSR) {
                        case ~/003B-634B-.*/: // Schlage FE5xx/BE3xx Series Generic
                            map.value = "disabled"
                            break

                        default:
                            map.value = "unknown"
                            map.displayed = false
                            break
                    }
                    break

                case 0xff:
                    switch (state.MSR) {
                        case ~/003B-6341-.*/: // Schlage FE/BE469 Generic
                        case ~/003B-6349-.*/: // Schlage BE468 Generic
                            map.value = "disabled"
                            break

                        default:
                            map.value = "unknown"
                            map.displayed = false
                            break
                    }
                    break

                default:
                    map.value = "unknown"
                    map.displayed = false
                    break
            }
            break

        case 0x05: // Lock and Leave
            map = [name: "onetouchlock", descriptionText: "Lock and Leave"]
            switch (cmd.configurationValue[0]) {
                case 0x0:
                    map.value = "disabled"
                    break

                case 0xFF:
                    map.value = "enabled"
                    break

                default:
                    map.value = "unknown"
                    map.displayed = false
                    break
            }
            break

        case 0x07: // Lock specific alarm mode
            map = [name: "alarm", descriptionText: "Alarm Mode"]
            switch (cmd.configurationValue[0]) {
                case 0:
                    map.value = "off"
                    break

                case 0x1:
                    map.value = "alert"
                    break

                case 0x2:
                    map.value = "tamper"
                    break

                case 0x3:
                    map.value = "forced"
                    break

                default:
                    map.value = "unknown"
                    map.displayed = false
                    break
            }
            break

        case 0x08:
        case 0x09:
        case 0x0A: // Lock specific alarm sensitivity level
            map = [name: "sensitive", descriptionText: "Alarm Sensitivity Level"]
            switch (cmd.configurationValue[0]) {
                case 0x1:
                    map.value = "highest"
                    break

                case 0x2:
                    map.value = "high"
                    break

                case 0x3:
                    map.value = "medium"
                    break

                case 0x4:
                    map.value = "low"
                    break

                case 0x5:
                    map.value = "lowest"
                    break

                default:
                    map.value = "unknown"
                    map.displayed = false
                    break
            }
            break

        case 0x0F: // Auto lock
            map = [name: "autolock", descriptionText: "Auto lock"]
            switch (cmd.configurationValue[0]) {
                case 0:
                    map.value = "disabled"
                    break

                case 0xff:
                    map.value = "enabled"
                    break

                default:
                    map.value = "unknown"
                    map.displayed = false
                    break
            }
            break

        case 0x10: // Pin code length
            def length = cmd.scaledConfigurationValue
            def deviceName = device.displayName
            log.trace "[DTH] Executing 'ConfigurationReport' for device $deviceName with code length := $length"
            def codeLength = device.currentValue("codeLength")
            if (codeLength && codeLength != length) {
                log.trace "[DTH] Executing 'ConfigurationReport' for device $deviceName - all codes deleted"
                result = allCodesDeletedEvent()
                result << createEvent(name: "codeChanged", value: "all deleted", descriptionText: "Deleted all user codes", isStateChange: true, data: [lockName: deviceName, notify: true, notificationText: "Deleted all user codes in $deviceName at ${location.name}"])
                result << createEvent(name: "lockCodes", value: util.toJson([:]), displayed: false, descriptionText: "'lockCodes' attribute updated")
            }
            result << createEvent(name:"codeLength", value: length, descriptionText: "Code length is $length", displayed: false)
            break

        default:
            map = [ displayed: false, descriptionText: "$device.displayName: Parameter $cmd.parameterNumber configuration $cmd.configurationValue" ]
            break
    }

    return (map ? createEvent(map) : result)
}

private getKeypadState() {
    log.debug "Getting keypad state"

    def parameter
    def security = true
    if (isSchlageLock()) { // Schlage lock
        log.trace "Found Schlage"
        parameter = 4
    } else if (isYaleLock()) { // Yale lock
        log.trace "Found Yale"
        parameter = 8
    } else if (isIDLock()) { // IDLock
        log.trace "Found IDLock"
        security = false // ID Lock uses non secure channel for configuration class
        parameter = 1
    } else if (isSamsungLock()) { // Samsung
        log.trace "Found Samsung"
        parameter = samsungParamMap.PrivacyMode.Param
    } else {
        log.warn "Unknown device with MSR $state.MSR, keypad state not available"
        sendEvent(name: "codeunlock", value: "", displayed: false) // Not supported
        return
    }

    security ? secure(zwave.configurationV1.configurationGet(parameterNumber: parameter)) : zwave.configurationV1.configurationGet(parameterNumber: parameter).format()
}	

def enableKeypad() {
    log.debug "Enabling keypad"

    if (!(device.currentState('codeunlock')?.value && (device.currentState('codeunlock')?.value != "unknown"))) { // Check if we have succesfully managed to read the feature state, if not then it isn't supported
        log.warn "Unsupported device with MSR $state.MSR, Keypad enable feature not available"
        sendEvent(name: "contactDeveloper", value: "Feature not supported, MSR $state.MSR", isStateChange: true, displayed: true) // Report to dev with MSR
        return
    }

    def parameter
    def security = true
    def value = []
    if (isSchlageLock()) { // Schlage lock
        parameter = 4
        value = [0]
    } else if (isYaleLock()) { // Yale lock
        parameter = 8
        value = [0]
    } else if (isIDLock()) { // IDLock
        security = false // ID Lock uses non secure channel for configuration class
        parameter = 1
        if (device.currentValue("autolock") == "enabled") { // Away mode enabled = keypad disabled
            value = [0x0 | 0x1] // Bit 1 AutoLock, Bit 2 Away mode
        } else if (device.currentValue("autolock") == "disabled") {
            value = [0x0 | 0x0] // Bit 1 AutoLock, Bit 2 Away mode
        } else {
            log.error "IDLock device with MSR $state.MSR, cannot determine AutoLock state, not enabling Keypad"
            sendEvent(descriptionText: "Cannot determine Keypad state, not enabling Keypad", isStateChange: true, displayed: true)
            return
        }
    } else if (isSamsungLock()) { // Samsung
        parameter = samsungParamMap.PrivacyMode.Param
        value = [samsungParamMap.PrivacyMode.Disabled]
    } else {
        log.warn "Unknown device with MSR $state.MSR, report it to developer"
        sendEvent(name: "contactDeveloper", value: "Unknown lock. Contact developer, quote MSR $state.MSR", isStateChange: true, displayed: true) // Report to dev with MSR
        return
    }

    if (security) {
        secureSequence([
            zwave.configurationV1.configurationSet(parameterNumber: parameter, configurationValue: value),
            zwave.configurationV1.configurationGet(parameterNumber: parameter)
        ], 5000)
    } else {
        delayBetween([
            zwave.configurationV1.configurationSet(parameterNumber: parameter, configurationValue: value).format(),
            zwave.configurationV1.configurationGet(parameterNumber: parameter).format()
        ], 5000)
    }
}	

def disableKeypad() {
    log.debug "Disabling keypad"

    if (!(device.currentState('codeunlock')?.value && (device.currentState('codeunlock')?.value != "unknown"))) { // Check if we have succesfully managed to read the feature state, if not then it isn't supported
        log.warn "Unsupported device with MSR $state.MSR, Keypad disable feature not available"
        sendEvent(name: "contactDeveloper", value: "Feature not supported, MSR $state.MSR", isStateChange: true, displayed: true) // Report to dev with MSR
        return
    }

    def parameter
    def security = true
    if (isSchlageLock()) { // Schlage lock
        parameter = 4
    } else if (isYaleLock()) { // Yale lock
        parameter = 8
    } else if (isIDLock()) { // IDLock
        security = false // ID Lock uses non secure channel for configuration class
        parameter = 1
    } else if (isSamsungLock()) { // Samsung
        parameter = samsungParamMap.PrivacyMode.Param
    } else {
        log.warn "Unknown device with MSR $state.MSR, report it to developer"
        sendEvent(name: "contactDeveloper", value: "Unknown lock. Contact developer, quote MSR $state.MSR", isStateChange: true, displayed: true) // Report to dev with MSR
        return
    }

    def value = []
    switch (state.MSR) { // check if we have a supported device
        // First do specific cases before moving to generic cases with regex matching
        case ~/003B-6341-.*/: // Schlage FE/BE469 Generic
        case ~/003B-6349-.*/: // Schlage BE468 Generic
            value = [255]
            break

        case ~/003B-634B-.*/: // Schlage FE5xx/BE3xx Series Generic
            value = [1]
            break

        case ~/0109-.*/: // Yale locks
        case ~/0129-.*/: // Yale locks
            value = [1] // Vacation mode (don't use privacy mode for consistency)
            break

        case ~/0230-0003-.*/: // IDLock
            if (device.currentValue("autolock") == "enabled") { // Away mode enabled = keypad disabled
                value = [0x2 | 0x1] // Bit 1 AutoLock, Bit 2 Away mode
            } else if (device.currentValue("autolock") == "disabled") {
                value = [0x2 | 0x0] // Bit 1 AutoLock, Bit 2 Away mode
            } else {
                log.error "IDLock device with MSR $state.MSR, cannot determine AutoLock state, not disabling Keypad"
                sendEvent(descriptionText: "Cannot determine AutoLock state, not disabling Keypad", isStateChange: true, displayed: true)
                return
            }
            break

        case ~/022E-.*/: // Samsung locks
            value = [samsungParamMap.PrivacyMode.Enabled]
            break

        default:
            value = [255] // Default most Schlage locks use this try it out
            log.warn "Unknown Schlage device with MSR $state.MSR, contact developer, Keypad disable feature may not work"
            sendEvent(name: "contactDeveloper", value: "Unsupported lock. Contact developer, quote MSR $state.MSR", isStateChange: true, displayed: true) // Report to dev with MSR
            break
    }

    if (security) {
        secureSequence([
            zwave.configurationV1.configurationSet(parameterNumber: parameter, configurationValue: value),
            zwave.configurationV1.configurationGet(parameterNumber: parameter)
        ], 5000)
    } else {
        delayBetween([
            zwave.configurationV1.configurationSet(parameterNumber: parameter, configurationValue: value).format(),
            zwave.configurationV1.configurationGet(parameterNumber: parameter).format()
        ], 5000)
    }
}	

private getAudioState() {
    log.debug "Getting audio/beeper state"

    def parameter
    if (isSchlageLock()) { // Schlage lock
        log.trace "Found Schlage"
        parameter = 3
    } else if (isYaleLock()) { // Yale lock
        log.trace "Found Yale"
        parameter = 1
    } else if (isKwiksetLock()) { // kwikset lock
        log.trace "Found Kwikset Lock"
        parameter = 31
    } else if (isDanaLockV2()) { // Danalock V2
        log.trace "Found Danalock V2"
        parameter = 6
    } else {
        log.warn "Unknown device with MSR $state.MSR, Audio/Beeper feature not available"
        sendEvent(name: "beeper", value: "", displayed: false) // Not supported
        return
    }

    secure(zwave.configurationV1.configurationGet(parameterNumber: parameter))
}	

def enableAudio() {
    log.debug "Enabling audio/beeper" 

    if (!(device.currentState('beeper')?.value && (device.currentState('beeper')?.value != "unknown"))) { // Check if we have succesfully managed to read the feature state, if not then it isn't supported
        log.warn "Unsupported device with MSR $state.MSR, Audio/Beeper feature not available"
        sendEvent(name: "contactDeveloper", value: "Audio/Beeper feature not supported, MSR $state.MSR", isStateChange: true, displayed: true) // Report to dev with MSR
        return
    }

    def parameter
    def value = []
    if (isSchlageLock()) { // Schlage lock
        parameter = 3
        switch (state.MSR) {
            case ~/003B-634B-.*/: // Schlage FE5xx/BE3xx Series Generic
            value = [1]
            break

            default:
                value = [255]
            break
        }
    } else if (isYaleLock()) { // Yale lock
        parameter = 1
        switch (state.MSR) {
            case ~/0129-80.*/: // Commercial
                value = [1]
                break
            
            default: // Yale
                value = [3]
                break
        }
    } else if (isKwiksetLock()) { // Kwikset does not support setting remotely only reading
        log.warn "Kwikset lock does not support remotely enabling Audio, change settings on the lock"
        sendEvent(descriptionText: "Kwikset lock does not support remotely enabling Audio, change settings on the lock", isStateChange: true, displayed: true) // Report to dev with MSR
        return
    } else if (isDanaLockV2()) { // Danalock V2
        parameter = 6
        value = [1]
    } else {
        log.warn "Unknown device with MSR $state.MSR, report it to developer"
        sendEvent(name: "contactDeveloper", value: "Unknown lock. Contact developer, quote MSR $state.MSR", isStateChange: true, displayed: true) // Report to dev with MSR
        return
    }

    secureSequence([
        zwave.configurationV1.configurationSet(parameterNumber: parameter, configurationValue: value),
        zwave.configurationV1.configurationGet(parameterNumber: parameter)
    ], 5000)
}	

def disableAudio() {
    log.debug "Disabling audio/beeper" 

    if (!(device.currentState('beeper')?.value && (device.currentState('beeper')?.value != "unknown"))) { // Check if we have succesfully managed to read the feature state, if not then it isn't supported
        log.warn "Unsupported device with MSR $state.MSR, Audio/Beeper feature not available"
        sendEvent(name: "contactDeveloper", value: "Audio/Beeper feature not supported, MSR $state.MSR", isStateChange: true, displayed: true) // Report to dev with MSR
        return
    }

    def parameter
    def value = []
    if (isSchlageLock()) { // Schlage lock
        parameter = 3
        value = [0]
    } else if (isYaleLock()) { // Yale lock
        parameter = 1
        switch (state.MSR) {
            case ~/0129-80.*/: // Commercial
                value = [3]
                break
            
            default: // Yale
                value = [1]
                break
        }
    } else if (isKwiksetLock()) { // Kwikset does not support setting remotely only reading
        log.warn "Kwikset lock does not support remotely disabling Audio, change settings on the lock"
        sendEvent(descriptionText: "Kwikset lock does not support remotely disabling Audio, change settings on the lock", isStateChange: true, displayed: true) // Report to dev with MSR
        return
    } else if (isDanaLockV2()) { // Danalock V2
        parameter = 6
        value = [0]
    } else {
        log.warn "Unknown device with MSR $state.MSR, report it to developer"
        sendEvent(name: "contactDeveloper", value: "Unknown lock. Contact developer, quote MSR $state.MSR", isStateChange: true, displayed: true) // Report to dev with MSR
        return
    }

    secureSequence([
        zwave.configurationV1.configurationSet(parameterNumber: parameter, configurationValue: value),
        zwave.configurationV1.configurationGet(parameterNumber: parameter)
    ], 5000)
}	

private getOneTouchLockState() {
    log.debug "Getting OneTouch Lock state"

    def parameter
    def security = true
    if (isSchlageLock()) { // Schlage lock
        log.trace "Found Schlage"
        parameter = 5
    } else if (isYaleLock()) { // Yale lock
        log.trace "Found Yale"
        parameter = 11
    } else {
        log.warn "Unsupported device with MSR $state.MSR, OneTouch Lock feature not supported"
        sendEvent(name: "onetouchlock", value: "", displayed: false) // Not supported
        return
    }

    security ? secure(zwave.configurationV1.configurationGet(parameterNumber: parameter)) : zwave.configurationV1.configurationGet(parameterNumber: parameter).format()
}	

def enableOneTouchLock() {
    log.debug "Enabling OneTouch Lock" 

    if (!(device.currentState('onetouchlock')?.value && (device.currentState('onetouchlock')?.value != "unknown"))) { // Check if we have succesfully managed to read the feature state, if not then it isn't supported
        log.warn "Unsupported device with MSR $state.MSR, OneTouch Lock feature not available"
        sendEvent(name: "contactDeveloper", value: "OneTouch Lock feature not supported, MSR $state.MSR", isStateChange: true, displayed: true) // Report to dev with MSR
        return
    }

    def parameter
    def security = true
    def value = []
    if (isSchlageLock()) { // Schlage lock
        parameter = 5
        value = [255]
    } else if (isYaleLock()) { // Yale lock
        parameter = 11
        value = [255]
    } else {
        log.warn "Unknown device with MSR $state.MSR, report it to developer"
        sendEvent(name: "contactDeveloper", value: "Unknown lock. Contact developer, quote MSR $state.MSR", isStateChange: true, displayed: true) // Report to dev with MSR
        return
    }

    if (security) {
        secureSequence([
            zwave.configurationV1.configurationSet(parameterNumber: parameter, configurationValue: value),
            zwave.configurationV1.configurationGet(parameterNumber: parameter)
        ], 5000)
    } else {
        delayBetween([
            zwave.configurationV1.configurationSet(parameterNumber: parameter, configurationValue: value).format(),
            zwave.configurationV1.configurationGet(parameterNumber: parameter).format()
        ], 5000)
    }
}	

def disableOneTouchLock() {
    log.debug "Disabling OneTouch Lock"

    if (!(device.currentState('onetouchlock')?.value && (device.currentState('onetouchlock')?.value != "unknown"))) { // Check if we have succesfully managed to read the feature state, if not then it isn't supported
        log.warn "Unsupported device with MSR $state.MSR, OneTouch Lock feature not available"
        sendEvent(name: "contactDeveloper", value: "OneTouch Lock feature not supported, MSR $state.MSR", isStateChange: true, displayed: true) // Report to dev with MSR
        return
    }

    def parameter
    def security = true
    def value = []
    if (isSchlageLock()) { // Schlage lock
        parameter = 5
        value = [0]
    } else if (isYaleLock()) { // Yale lock
        parameter = 11
        value = [0]
    } else {
        log.warn "Unknown device with MSR $state.MSR, report it to developer"
        sendEvent(name: "contactDeveloper", value: "Unknown lock. Contact developer, quote MSR $state.MSR", isStateChange: true, displayed: true) // Report to dev with MSR
        return
    }

    if (security) {
        secureSequence([
            zwave.configurationV1.configurationSet(parameterNumber: parameter, configurationValue: value),
            zwave.configurationV1.configurationGet(parameterNumber: parameter)
        ], 5000)
    } else {
        delayBetween([
            zwave.configurationV1.configurationSet(parameterNumber: parameter, configurationValue: value).format(),
            zwave.configurationV1.configurationGet(parameterNumber: parameter).format()
        ], 5000)
    }
}	

private getAutolockState() {
    log.debug "Getting AutoLock state"

    def parameter
    def security = true
    if (isSchlageLock()) { // Schlage lock
        log.trace "Found Schlage"
        parameter = 15
    } else if (isYaleLock()) { // Yale lock
        log.trace "Found Yale"
        parameter = 2
    } else if (isKwiksetLock()) { // kwikset lock
        log.trace "Found Kwikset"
        parameter = 31
    } else if (isIDLock()) { // IDLock
        log.trace "Found IDLock"
        security = false // ID Lock uses non secure channel for configuration class
        parameter = 1
    } else if (isDanaLockV2()) { // Danalock V2
        log.trace "Found Danalock V2"
        parameter = 5
    } else if (isDanaLockV3()) { // Danalock V3
        log.trace "Found Danalock V3"
        parameter = danalockV3ParamMap.AutoLock.Param
    } else {
        log.warn "Unsupported device with MSR $state.MSR, AutoLock feature not supported"
        sendEvent(name: "autolock", value: "", displayed: false) // Not supported
        return
    }

    security ? secure(zwave.configurationV1.configurationGet(parameterNumber: parameter)) : zwave.configurationV1.configurationGet(parameterNumber: parameter).format()
}	

def enableAutolock() {
    log.debug "Enabling AutoLock" 

    if (!(device.currentState('autolock')?.value && (device.currentState('autolock')?.value != "unknown"))) { // Check if we have succesfully managed to read the feature state, if not then it isn't supported
        log.warn "Unsupported device with MSR $state.MSR, AutoLock feature not available"
        sendEvent(name: "contactDeveloper", value: "AutoLock feature not supported, MSR $state.MSR", isStateChange: true, displayed: true) // Report to dev with MSR
        return
    }

    def parameter
    def security = true
    def value = []
    if (isSchlageLock()) { // Schlage lock
        parameter = 15
        value = [255]
    } else if (isYaleLock()) { // Yale lock
        parameter = 2
        value = [255]
    } else if (isIDLock()) { // IDLock
        security = false // ID Lock uses non secure channel for configuration class
        parameter = 1
        if (device.currentValue("codeunlock") == "enabled") { // Away mode enabled = keypad disabled
            value = [0x0 | 0x1] // Bit 1 AutoLock, Bit 2 Away mode
        } else if (device.currentValue("codeunlock") == "disabled") {
            value = [0x2 | 0x1] // Bit 1 AutoLock, Bit 2 Away mode
        } else {
            log.error "IDLock device with MSR $state.MSR, cannot determine Away mode state, not enabling AutoLock"
            sendEvent(descriptionText: "Cannot determine Away mode state, not enabling AutoLock", isStateChange: true, displayed: true)
            return
        }
    } else if (isKwiksetLock()) { // Kwikset does not support setting remotely only reading
        log.warn "Kwikset lock does not support remotely enabling AutoLock, change settings on the lock"
        sendEvent(descriptionText: "Kwikset lock does not support remotely enabling AutoLock, change settings on the lock", isStateChange: true, displayed: true) // Report to dev with MSR
        return
    } else if (isDanaLockV2()) { // Danalock V2
        parameter = 5
        value = [danaRelockTime ? (danaRelockTime <= 60 ? danaRelockTime : 60) : 30] // Default is 30 if not specified in settings, maximum value is 60 for V2 locks
    } else if (isDanaLockV3()) { // Danalock V3
        parameter = danalockV3ParamMap.AutoLock.Param
        value = getDanalockV3ParamMap(danaRelockTime ?: 30).AutoLock.ParamValue // Default is 30 if not specified in settings
    } else {
        log.warn "Unknown device with MSR $state.MSR, report it to developer"
        sendEvent(name: "contactDeveloper", value: "Unknown lock. Contact developer, quote MSR $state.MSR", isStateChange: true, displayed: true) // Report to dev with MSR
        return
    }

    if (security) {
        secureSequence([
            zwave.configurationV1.configurationSet(parameterNumber: parameter, configurationValue: value),
            zwave.configurationV1.configurationGet(parameterNumber: parameter)
        ], 5000)
    } else {
        delayBetween([
            zwave.configurationV1.configurationSet(parameterNumber: parameter, configurationValue: value).format(),
            zwave.configurationV1.configurationGet(parameterNumber: parameter).format()
        ], 5000)
    }
}	

def disableAutolock() {
    log.debug "Disabling AutoLock"

    if (!(device.currentState('autolock')?.value && (device.currentState('autolock')?.value != "unknown"))) { // Check if we have succesfully managed to read the feature state, if not then it isn't supported
        log.warn "Unsupported device with MSR $state.MSR, AutoLock feature not available"
        sendEvent(name: "contactDeveloper", value: "AutoLock feature not supported, MSR $state.MSR", isStateChange: true, displayed: true) // Report to dev with MSR
        return
    }

    def parameter
    def security = true
    def value = []
    if (isSchlageLock()) { // Schlage lock
        parameter = 15
        value = [0]
    } else if (isYaleLock()) { // Yale lock
        parameter = 2
        value = [0]
    } else if (isIDLock()) { // IDLock
        security = false // ID Lock uses non secure channel for configuration class
        parameter = 1
        if (device.currentValue("codeunlock") == "enabled") { // Away mode enabled = keypad disabled
            value = [0x0 | 0x0] // Bit 1 AutoLock, Bit 2 Away mode
        } else if (device.currentValue("codeunlock") == "disabled") {
            value = [0x2 | 0x0] // Bit 1 AutoLock, Bit 2 Away mode
        } else {
            log.error "IDLock device with MSR $state.MSR, cannot determine Away mode state, not disabling AutoLock"
            sendEvent(descriptionText: "Cannot determine Away mode state, not disabling AutoLock", isStateChange: true, displayed: true)
            return
        }
    } else if (isKwiksetLock()) { // Kwikset does not support setting remotely only reading
        log.warn "Kwikset lock does not support remotely disabling AutoLock, change settings on the lock"
        sendEvent(descriptionText: "Kwikset lock does not support remotely disabling AutoLock, change settings on the lock", isStateChange: true, displayed: true) // Report to dev with MSR
        return
    } else if (isDanaLockV2()) { // Danalock V2
        parameter = 5
        value = [0]
    } else if (isDanaLockV3()) { // Danalock V3
        parameter = danalockV3ParamMap.AutoLock.Param
        value = getDanalockV3ParamMap(0).AutoLock.ParamValue
    } else {
        log.warn "Unknown device with MSR $state.MSR, report it to developer"
        sendEvent(name: "contactDeveloper", value: "Unknown lock. Contact developer, quote MSR $state.MSR", isStateChange: true, displayed: true) // Report to dev with MSR
        return
    }

    if (security) {
        secureSequence([
            zwave.configurationV1.configurationSet(parameterNumber: parameter, configurationValue: value),
            zwave.configurationV1.configurationGet(parameterNumber: parameter)
        ], 5000)
    } else {
        delayBetween([
            zwave.configurationV1.configurationSet(parameterNumber: parameter, configurationValue: value).format(),
            zwave.configurationV1.configurationGet(parameterNumber: parameter).format()
        ], 5000)
    }
}	

private modes() {
    ["off", "alert", "tamper", "forced"]
}

private getModeMap() {
    [
        "off": 0,
        "alert": 1,
        "tamper": 2,
        "forced": 3
    ]
}

private getAlarmLevel() {
    log.debug "Getting Alarm Level"

    def parameter
    def security = true
    if (isSchlageLock()) { // Schlage lock
        log.trace "Found Schlage"
        parameter = 7
    } else {
        log.warn "Unsupported device with MSR $state.MSR, Alarm feature not supported"
        sendEvent(name: "alarm", value: "", displayed: false) // Not supported
        runIn(5, updateTiles) // Update the alarm status on the tiles after 5 seconds giving it time to register
        return
    }

    security ? secure(zwave.configurationV1.configurationGet(parameterNumber: parameter)) : zwave.configurationV1.configurationGet(parameterNumber: parameter).format()
}

def setAlarm(String newMode) {
    log.debug "Set Alarm level to $newMode"

    if (!(device.currentState('alarm')?.value && (device.currentState('alarm')?.value != "unknown"))) { // Check if we have succesfully managed to read the feature state, if not then it isn't supported
        log.warn "Unsupported device with MSR $state.MSR, Alarm feature not available"
        sendEvent(name: "contactDeveloper", value: "Alarm feature not supported, MSR $state.MSR", isStateChange: true, displayed: true) // Report to dev with MSR
        return
    }

    if (!modes().contains(newMode)) {
        log.error "Request to set unknown Alarm mode $newMode"
        return
    }

    log.info "SetAlarm setting Alarm mode to $newMode -> ${[modeMap[newMode]]}"

    def parameter
    def value = []
    def security = true
    if (isSchlageLock()) { // Schlage lock
        log.trace "Found Schlage"
        parameter = 7
        value = [modeMap[newMode]]
    } else {
        log.warn "Unknown device with MSR $state.MSR, report it to developer"
        sendEvent(name: "contactDeveloper", value: "Unknown lock. Contact developer, quote MSR $state.MSR", isStateChange: true, displayed: true) // Report to dev with MSR
        return
    }

    if (security) {
        delayBetween([
            secure(zwave.configurationV1.configurationSet(parameterNumber: parameter, configurationValue: value)),
            secure(zwave.configurationV1.configurationGet(parameterNumber: parameter)),
            getSensitiveLevel(newMode) // Get the level after the alarm
        ], 5000)
    } else {
        delayBetween([
            zwave.configurationV1.configurationSet(parameterNumber: parameter, configurationValue: value).format(),
            zwave.configurationV1.configurationGet(parameterNumber: parameter).format(),
            getSensitiveLevel(newMode) // Get the level after the alarm
        ], 5000)
    }
}

def alarmToggle() {
    log.debug "Set Alarm Toggle"

    if (!(device.currentState('alarm')?.value && (device.currentState('alarm')?.value != "unknown"))) { // Check if we have succesfully managed to read the feature state, if not then it isn't supported
        log.warn "Unsupported device with MSR $state.MSR, Alarm feature not available"
        sendEvent(name: "contactDeveloper", value: "Alarm feature not supported, MSR $state.MSR", isStateChange: true, displayed: true) // Report to dev with MSR
        return
    }

    def currentMode = device.currentState("alarm")?.value
    log.trace "AlarmToggle Current Alarm mode is $currentMode"
    if (!currentMode) { // Sometime when the initialization is not complete, we get a null here, so avoid a crash and wait
        log.warn "Lock initialization not complete, deferring toggle alarm. Try again later after refreshing lock status."
        return
    }

    def modeOrder = modes()
    def next = { modeOrder[modeOrder.indexOf(it) + 1] ?: modeOrder[0] }
    def nextMode = next(currentMode)

    def parameter
    def value = []
    def security = true
    if (isSchlageLock()) { // Schlage lock
        log.trace "Found Schlage"

        log.info "AlarmToggle Setting Alarm mode to $nextMode -> ${modeMap[nextMode]}"

        parameter = 7
        value = [modeMap[nextMode]]
    } else {
        log.warn "Unknown device with MSR $state.MSR, report it to developer"
        sendEvent(name: "contactDeveloper", value: "Unknown lock. Contact developer, quote MSR $state.MSR", isStateChange: true, displayed: true) // Report to dev with MSR
        return
    }

    if (security) {
        delayBetween([
            secure(zwave.configurationV1.configurationSet(parameterNumber: parameter, configurationValue: value)),
            secure(zwave.configurationV1.configurationGet(parameterNumber: parameter)),
            getSensitiveLevel(nextMode) // Get the level after the alarm
        ], 5000)
    } else {
        delayBetween([
            zwave.configurationV1.configurationSet(parameterNumber: parameter, configurationValue: value).format(),
            zwave.configurationV1.configurationGet(parameterNumber: parameter).format(),
            getSensitiveLevel(nextMode) // Get the level after the alarm
        ], 5000)
    }
}

private sensitives() {
    ["lowest", "low", "medium", "high", "highest"]
}

private getSensitiveMap() {
    [
        "highest": 1,
        "high": 2,
        "medium": 3,
        "low": 4,
        "lowest" : 5
    ]
}

private getSensitiveLevel() {
    def currentMode = device.currentState("alarm")?.value
    getSensitiveLevel(currentMode)
}

private getSensitiveLevel(currentMode) {
    log.debug "Getting Sensitivity Level, current Alarm Mode $currentMode"

    if (!(currentMode && (currentMode != "unknown"))) { // Sometime when the initialization is not complete, we get a null here or if Alarm is unsupported we get a unknown, so avoid a crash and wait
        log.warn "Lock Alarm mode not configured or not supported, deferring getting Alarm sensitivity level."
        sendEvent(name: "sensitive", value: "", displayed: false, isStateChange: true) // There is no sensitive level for off
        runIn(5, updateTiles) // Update the alarm status on the tiles after 5 seconds giving it time to register
        return
    }

    def parameter
    def security = true
    if (isSchlageLock()) { // Schlage lock
        log.trace "Found Schlage"
        int currentModeValue = modeMap[currentMode]
        log.trace "GetSensitiveLevel Current Alarm mode is $currentMode -> $currentModeValue"
        if (currentMode == "off") { // In off mode there is no sensitivity level
            log.info "There is no sensitive level when alarm is in off mode"
            sendEvent(name: "sensitive", value: "", displayed: false, isStateChange: true) // There is no sensitive level for off
            runIn(5, updateTiles) // Update the alarm status on the tiles after 5 seconds giving it time to register
            return
        }
        parameter = 7 + currentModeValue
    } else {
        log.warn "Unsupported device with MSR $state.MSR, Alarm Sensitivity feature not supported"
        sendEvent(name: "sensitive", value: "", displayed: false) // Not supported
        runIn(5, updateTiles) // Update the alarm status on the tiles after 5 seconds giving it time to register
        return
    }

    security ? secure(zwave.configurationV1.configurationGet(parameterNumber: parameter)) : zwave.configurationV1.configurationGet(parameterNumber: parameter).format()
}

def setSensitivity(String newMode) {
    log.debug "Set Alarm Sensitivity to $newMode"

    if (!(device.currentState('sensitive')?.value && (device.currentState('alarm')?.value != "unknown"))) { // Check if we have succesfully managed to read the feature state, if not then it isn't supported
        log.warn "Unsupported device with MSR $state.MSR, Alarm Sensitivity feature not available"
        sendEvent(name: "contactDeveloper", value: "Alarm Sensitivity feature not supported, MSR $state.MSR", isStateChange: true, displayed: true) // Report to dev with MSR
        return
    }

    if (!sensitives().contains(newMode)) {
        log.error "Request to set unknown Alarm sensitivity $newMode"
        return
    }

    def currentMode = device.currentState("alarm")?.value
    if (!currentMode) { // Sometime when the initialization is not complete, we get a null here, so avoid a crash and wait
        log.debug "Lock Alarm mode not configured or not supported, deferring getting Alarm sensitivity level."
        sendEvent(name: "sensitive", value: "", displayed: false, isStateChange: true) // There is no sensitive level for off
        runIn(5, updateTiles) // Update the alarm status on the tiles after 5 seconds giving it time to register
        return
    }

    def parameter
    def value = []
    def security = true
    if (isSchlageLock()) { // Schlage lock
        log.trace "Found Schlage"
        int currentModeValue = modeMap[currentMode]
        log.trace "SensitiveToggle Current Alarm mode is $currentMode -> $currentModeValue"
        if (currentMode == "off") { // In off mode there is no sensitivity level
            log.info "There is no sensitive level when alarm is in off mode"
            sendEvent(name: "sensitive", value: "", displayed: false, isStateChange: true) // There is no sensitive level for off
            runIn(5, updateTiles) // Update the alarm status on the tiles after 5 seconds giving it time to register
            return
        }

        log.info "Set Alarm Sensitivity to $newMode -> ${[sensitiveMap[newMode]]}"

        parameter = 7 + currentModeValue
        value = [sensitiveMap[newMode]]
    } else {
        log.warn "Unknown device with MSR $state.MSR, report it to developer"
        sendEvent(name: "contactDeveloper", value: "Unknown lock. Contact developer, quote MSR $state.MSR", isStateChange: true, displayed: true) // Report to dev with MSR
        return
    }

    if (security) {
        secureSequence([
            zwave.configurationV1.configurationSet(parameterNumber: parameter, configurationValue: value),
            zwave.configurationV1.configurationGet(parameterNumber: parameter),
        ], 5000)
    } else {
        delayBetween([
            zwave.configurationV1.configurationSet(parameterNumber: parameter, configurationValue: value).format(),
            zwave.configurationV1.configurationGet(parameterNumber: parameter).format(),
        ], 5000)
    }
}

def sensitiveToggle() {
    log.debug "Set Alarm Sensitivity Toggle"

    if (!(device.currentState('sensitive')?.value && (device.currentState('alarm')?.value != "unknown"))) { // Check if we have succesfully managed to read the feature state, if not then it isn't supported
        log.warn "Unsupported device with MSR $state.MSR, Alarm Sensitivity feature not available"
        sendEvent(name: "contactDeveloper", value: "Alarm Sensitivity feature not supported, MSR $state.MSR", isStateChange: true, displayed: true) // Report to dev with MSR
        return
    }

    def currentMode = device.currentState("alarm")?.value
    if (!currentMode) { // Sometime when the initialization is not complete, we get a null here, so avoid a crash and wait
        log.debug "Lock Alarm mode not configured or not supported, deferring getting Alarm sensitivity level."
        sendEvent(name: "sensitive", value: "", displayed: false, isStateChange: true) // There is no sensitive level for off
        runIn(5, updateTiles) // Update the alarm status on the tiles after 5 seconds giving it time to register
        return
    }

    def parameter
    def value = []
    def security = true
    if (isSchlageLock()) { // Schlage lock
        log.trace "Found Schlage"
        int currentModeValue = modeMap[currentMode]
        log.trace "SensitiveToggle Current Alarm mode is $currentMode -> $currentModeValue"
        if (currentMode == "off") { // In off mode there is no sensitivity level
            log.info "There is no sensitive level when alarm is in off mode"
            sendEvent(name: "sensitive", value: "", displayed: false, isStateChange: true) // There is no sensitive level for off
            runIn(5, updateTiles) // Update the alarm status on the tiles after 5 seconds giving it time to register
            return
        }

        def currentSensitive = device.currentState("sensitive")?.value
        log.trace "SensitiveToggle Current Alarm sensitivity is $currentSensitive"
        def SensitiveOrder = sensitives()
        def next = { SensitiveOrder[SensitiveOrder.indexOf(it) + 1] ?: SensitiveOrder[0] }
        def nextSensitive = next(currentSensitive)

        log.info "Toggling Alarm Sensitivity to $nextSensitive -> ${sensitiveMap[nextSensitive]}"

        parameter = 7 + currentModeValue
        value = [sensitiveMap[nextSensitive]]
    } else {
        log.warn "Unknown device with MSR $state.MSR, report it to developer"
        sendEvent(name: "contactDeveloper", value: "Unknown lock. Contact developer, quote MSR $state.MSR", isStateChange: true, displayed: true) // Report to dev with MSR
        return
    }

    if (security) {
        secureSequence([
            zwave.configurationV1.configurationSet(parameterNumber: parameter, configurationValue: value),
            zwave.configurationV1.configurationGet(parameterNumber: parameter),
        ], 5000)
    } else {
        delayBetween([
            zwave.configurationV1.configurationSet(parameterNumber: parameter, configurationValue: value).format(),
            zwave.configurationV1.configurationGet(parameterNumber: parameter).format(),
        ], 5000)
    }
}

/**
 * Getting the battery state
 *
 * @returns The command fired for getting the battery state on a lock
 */
private getBatteryState() {
    // Some locks implement non secure reading of battery
    def security = true

    if (isIDLock()) { // IDLock
        security = false
    }

    security ? secure(zwave.batteryV1.batteryGet()) : zwave.batteryV1.batteryGet().format()
}

/**
 * Configuring the parameters on a lock
 *
 * @returns The command fired for sending the configuration settings to the lock or null if it's an unsupported lock
 */
private configureLock() {
    log.trace "$device.displayName: Configuring lock settings"
    def map = null

    if (isSchlageLock()) { // Schlage lock
        map = schlageConfigureLock()
    } else if (isYaleLock()) { // Yale lock
        map = yaleConfigureLock()
    } else if (isKwiksetLock()) { // Kwikset lock
        map = kwiksetConfigureLock()
    } else if (isIDLock()) { // IDLock
        map = idLockConfigureLock()
    } else if (isDanaLockV2()) { // Danalock V2
        map = danaLockConfigureLockV2()
    } else if (isDanaLockV3()) { // Danalock V3
        map = danaLockConfigureLockV3()
    } else {
        log.warn "Unsupported device with MSR $state.MSR"
    }

    return map    
}

private yaleConfigureLock() {
    log.trace "Configure Yale settings"
    def cmds = []

    if (yaleWrongCodeLimit) {
        if (yaleWrongCodeLimit >=1 && yaleWrongCodeLimit <= 7) {
            log.info "Setting Wrong Code Tamper Alert threshold to $yaleWrongCodeLimit"

            cmds << zwave.configurationV1.configurationSet(parameterNumber: 4, configurationValue: [yaleWrongCodeLimit])
            cmds << zwave.configurationV1.configurationGet(parameterNumber: 4)
        } else {
            log.warn "Wrong Code Tamper Alert threshold INVALID (between 1 and 7) -> $yaleWrongCodeLimit"
        }
    }

    if (yaleRelockTime) {
        if (yaleRelockTime >=5 && yaleRelockTime <= 255) {
            log.info "Setting Auto Relock time to $yaleRelockTime seconds"

            cmds << zwave.configurationV1.configurationSet(parameterNumber: 3, configurationValue: [yaleRelockTime])
            cmds << zwave.configurationV1.configurationGet(parameterNumber: 3)
        } else {
            log.warn "Auto Relock time INVALID (between 5 and 255) -> $yaleRelockTime seconds"
        }
    }

    log.info "${yaleDPS ? "Enabling" : "Disabling"} DPS functionality"
    cmds << zwave.configurationV1.configurationSet(parameterNumber: 19, configurationValue: [yaleDPS ? 255 : 0])
    cmds << zwave.configurationV1.configurationGet(parameterNumber: 19)

    cmds ? secureSequence(cmds, 5000) : null
}

private kwiksetConfigureLock() {
    log.trace "Configure Kwikset settings"
    def cmds = []

    cmds ? secureSequence(cmds, 5000) : null
}

private schlageConfigureLock() {
    log.trace "Configure Schlage settings"
    def cmds = []

    cmds ? secureSequence(cmds, 5000) : null
}

private idLockConfigureLock() {
    log.trace "Configure IDLock settings"
    def cmds = []

    cmds ? secureSequence(cmds, 5000) : null
}

private danaLockConfigureLockV3() {
    log.trace "Configure Danalock V3 settings"
    def cmds = []

    if (danaBrakeGoBack != null && danaBrakeGoBack != "") {
        if (danaBrakeGoBack >= danalockV3ParamMap.BrakeAndGo.Min && danaBrakeGoBack <= danalockV3ParamMap.BrakeAndGo.Max) {
            if (danaBrakeGoBack == danalockV3ParamMap.BrakeAndGo.Min) {
                log.info "Disabling Brake & Go back"
            } else {
                log.info "Setting Brake & Go Back time to $danaBrakeGoBack seconds"
            }

            cmds << zwave.configurationV1.configurationSet(parameterNumber: danalockV3ParamMap.BrakeAndGo.Param, configurationValue: getDanalockV3ParamMap(danaBrakeGoBack).BrakeAndGo.ParamValue)
            cmds << zwave.configurationV1.configurationGet(parameterNumber: danalockV3ParamMap.BrakeAndGo.Param)
        } else {
            log.warn "Brake & Go Back time INVALID (between ${danalockV3ParamMap.BrakeAndGo.Min} and ${danalockV3ParamMap.BrakeAndGo.Max}) -> $danaBrakeGoBack seconds"
        }
    }

    if (danaTurnGo != null) {
        if (danaTurnGo) {
            log.info "Enabling Turn & Go"
        } else {
            log.info "Disabling Turn & Go"
        }

        cmds << zwave.configurationV1.configurationSet(parameterNumber: danalockV3ParamMap.TurnAndGo.Param, configurationValue: [danaTurnGo ? danalockV3ParamMap.TurnAndGo.Enabled : danalockV3ParamMap.TurnAndGo.Disabled])
        cmds << zwave.configurationV1.configurationGet(parameterNumber: danalockV3ParamMap.TurnAndGo.Param)
    }

    cmds ? secureSequence(cmds, 5000) : null
}

private danaLockConfigureLockV2() {
    log.trace "Configure Danalock V2 settings"
    def cmds = []

    if (danaBrakeGoBack != null && danaBrakeGoBack != "") {
        if (danaBrakeGoBack >=0 && danaBrakeGoBack <= 15) {
            if (danaBrakeGoBack == 0) {
                log.info "Disabling Brake & Go back"
            } else {
                log.info "Setting Brake & Go Back time to $danaBrakeGoBack seconds"
            }

            cmds << zwave.configurationV1.configurationSet(parameterNumber: 10, configurationValue: [danaBrakeGoBack])
            cmds << zwave.configurationV1.configurationGet(parameterNumber: 10)
        } else {
            log.warn "Brake & Go Back time INVALID (between 0 and 15) -> $danaBrakeGoBack seconds"
        }
    }

    if (danaTurnGo != null) {
        if (danaTurnGo) {
            log.info "Enabling Turn & Go"
        } else {
            log.info "Disabling Turn & Go"
        }

        cmds << zwave.configurationV1.configurationSet(parameterNumber: 9, configurationValue: [danaTurnGo ? 1 : 0])
        cmds << zwave.configurationV1.configurationGet(parameterNumber: 9)
    }

    if (danaTurnSpeed) {
        if (danaTurnSpeed >=1 && danaTurnSpeed <= 5) {
            log.info "Setting speed to $danaTurnSpeed"

            cmds << zwave.configurationV1.configurationSet(parameterNumber: 2, configurationValue: [danaTurnSpeed])
            cmds << zwave.configurationV1.configurationGet(parameterNumber: 2)
        } else {
            log.warn "Turn speed INVALID (between 1 and 5) -> $danaTurnSpeed"
        }
    }

    cmds ? secureSequence(cmds, 5000) : null
}

def activateSmoke(String msg) {
    log.debug "$device.displayName: Activating smoke alarm sensor"
    sendEvent([ name: "smoke", value: "detected",  descriptionText: msg, displayed: true ])
}

def deactivateSmoke() {
    log.debug "$device.displayName: Deactivating smoke alarm sensor" 
    sendEvent([ name: "smoke", value: "clear",  descriptionText: "$device.displayName: Deactivating smoke/fire alarm sensor", displayed: true ])
}

def resetSmoke() {
    log.debug "$device.displayName: Resetting smoke alarm sensor" 
    sendEvent([ name: "smoke", value: "clear",  descriptionText: "$device.displayName: Resetting smoke/fire alarm sensor", displayed: true ])
}

def activateMotion(String msg) {
    log.debug "$device.displayName: Activating door tampering activity sensor" 
    sendEvent([ name: "motion", value: "active",  descriptionText: msg, displayed: true ])
}

def deactivateMotion() {
    log.debug "$device.displayName: Deactivating door tampering activity sensor" 
    sendEvent([ name: "motion", value: "inactive",  descriptionText: "$device.displayName: Deactivating door tampering activity sensor", displayed: true ])
    sendEvent([ name: "tamper", value: "clear",  descriptionText: "$device.displayName: Deactivating door tampering activity sensor", displayed: true ])
}

def resetMotion() {
    log.debug "$device.displayName: Resetting door tampering activity sensor" 
    sendEvent([ name: "motion", value: "inactive",  descriptionText: "$device.displayName: Resetting door tampering activity sensor", displayed: true ])
    sendEvent([ name: "tamper", value: "clear",  descriptionText: "$device.displayName: Resetting door tampering activity sensor", displayed: true ])
}

def setState(String position, String msg) {
    log.debug "$device.displayName: Setting door sensor: $position" 
    sendEvent([ name: "contact", value: position, descriptionText: msg ])
    sendEvent([ name: "contactX", value: position, displayed: false ])
}

def resetState() {
    log.debug "$device.displayName: Resetting door closed sensor" 
    sendEvent([ name: "contact", value: "closed", descriptionText: "$device.displayName Resetting door sensor as closed", displayed: true ])
    sendEvent([ name: "contactX", value: "unknown", displayed: false ])
}

def reLocked() {
    log.debug "$device.displayName: Sending lock door notification as a follow up the unlocked event for the non motorized deadbolt" 
    def map = [ name: "lock", value: "locked", method: "auto", displayed: true ]
    sendEvent(map)
}

// Dummy code for enabling switch interface on lock (uncomment the capability lock to use this)
def on() {
    lock()
}

def off() {
    unlock()
}

/**
 * Generic function for reading code Slot ID from AlarmReport command
 * @param cmd: The AlarmReport command
 * @return user code slot id
 */
def readCodeSlotId(physicalgraph.zwave.commands.alarmv2.AlarmReport cmd) {
	def codeID
	if(cmd.numberOfEventParameters == 1) {
		codeID = cmd.eventParameter[0]
	} else if(cmd.numberOfEventParameters >= 3) { // Yale doesn't follow Z-Wave specs and eventParameter contains user slot in 3rd byte e.g.: user 2 reported as [99, 3, 2, 1]
		codeID = cmd.eventParameter[2]
	} else {
		codeID = cmd.alarmLevel
	}
	codeID = isYaleLock() ? (codeID > 249 ? 0 : codeID) : codeID // Yale locks master code returns 251 and 0 and specs allow code upto 0xF9
	return codeID
}

/**
 * Returns true if this lock generates door lock operation report before alarm report, false otherwise
 * @return true if this lock generates door lock operation report before alarm report, false otherwise
 */
def generatesDoorLockOperationReportBeforeAlarmReport() {
	//Fix for ICP-2367, ICP-2366
    if(isYaleLock() && (
        ("0007" == zwaveInfo.prod && "0001" == zwaveInfo.model) ||
        ("6600" == zwaveInfo.prod && "0002" == zwaveInfo.model) )) {
        //Yale Keyless Connected Smart Door Lock
        return true
	}
	return false
}

// NOTE: There appears to be a bug with the hub pairing where the zwInfo shows 0000 for mfr, prod and model. Until that is fixed use state.MSR as it is queried from the lock
/**
 * Utility function to check if the lock manufacturer is Schlage
 *
 * @return true if the lock manufacturer is Schlage, else false
 */
def isSchlageLock() {
	if (state.MSR?.startsWith("003B")) {
		if("Schlage" != getDataValue("manufacturer")) {
			updateDataValue("manufacturer", "Schlage")
		}
		return true
	}
	return false
}

/**
 * Utility function to check if the lock manufacturer is Kwikset
 *
 * @return true if the lock manufacturer is Kwikset, else false
 */
def isKwiksetLock() {
	if (state.MSR?.startsWith("0090")) {
		if("Kwikset" != getDataValue("manufacturer")) {
			updateDataValue("manufacturer", "Kwikset")
		}
		return true
	}
	return false
}

/**
 * Utility function to check if the lock manufacturer is Yale
 *
 * @return true if the lock manufacturer is Yale, else false
 */
def isYaleLock() {
	if (state.MSR?.startsWith("0129") || state.MSR?.startsWith("0109")) {
		if("Yale" != getDataValue("manufacturer")) {
			updateDataValue("manufacturer", "Yale")
		}
		return true
	}
	return false
}

/**
 * Utility function to check if the lock manufacturer is Danalock (type V2)
 *
 * @return true if the lock manufacturer is Danalock type V2, else false
 */
def isDanaLockV2() {
	if (state.MSR?.startsWith("010E-0008")) {
		if("Danalock" != getDataValue("manufacturer")) {
			updateDataValue("manufacturer", "Danalock")
		}
		return true
	}
	return false
}

/**
 * Utility function to check if the lock manufacturer is Danalock (type V3)
 *
 * @return true if the lock manufacturer is Danalock type V3, else false
 */
def isDanaLockV3() {
	if (state.MSR?.startsWith("010E-0009")) {
		if("Danalock" != getDataValue("manufacturer")) {
			updateDataValue("manufacturer", "Danalock")
		}
		return true
	}
	return false
}

/**
 * Utility function to check if the lock manufacturer is August
 *
 * @return true if the lock manufacturer is August, else false
 */
def isAugustLock() {
	if (state.MSR?.startsWith("033F")) {
		if("August" != getDataValue("manufacturer")) {
			updateDataValue("manufacturer", "August")
		}
		return true
	}
	return false
}

/**
 * Utility function to check if the lock manufacturer is IDLock
 *
 * @return true if the lock manufacturer is IDLock, else false
 */
def isIDLock() {
	if (state.MSR?.startsWith("0230")) {
		if("IDLock" != getDataValue("manufacturer")) {
			updateDataValue("manufacturer", "IDLock")
		}
		return true
	}
	return false
}

/**
 * Utility function to check if the lock manufacturer is Samsung
 *
 * @return true if the lock manufacturer is Samsung, else false
 */
def isSamsungLock() {
	if (state.MSR?.startsWith("022E")) {
		if("Samsung" != getDataValue("manufacturer")) {
			updateDataValue("manufacturer", "Samsung")
		}
		return true
	}
	return false
}

private paramValue(value, bytes) {
    if (value == null || !(value instanceof Number)) {
        return null
    }

    //log.trace "Param value: $value, $bytes"

    List<Integer> ret = [] // We start with a Integer list and then convert to array (since arrays are fixed in size)
    for (int i=0; i<bytes; i++) {
        ret = [(((value as Long) >> (i*8)) & 0xFF) as Integer] + ret
    }

    //log.debug ret as Integer[]

    return ret as Integer[] // We need an integer array
}

private reverseValue(value) {
    if (!value || !List.isCase(value)) {
        return null
    }

    //log.trace "Reverse value: $value, $bytes"

    Long ret = 0
    for (int i=0; i<value.size(); i++) {
        ret |= ((((value[i] as Integer) & 0xFF) as Long) << ((value.size() - 1 - i) * 8)) as Long
    }

    //log.debug ret

    return ret
}

private getDanalockV3ParamMap(value = null) {
    [
        "TurnAndGo": 			[ Param: 1, Size: 1, Default: 0, Enabled: 1, Disabled: 0 ], // Twist Assist
        "BrakeAndGo": 			[ Param: 2, Size: 4, Default: 0, Min: 0, Max: 2147483647, Value: reverseValue(value) ].with { put('ParamValue', paramValue(value, get('Size'))); it }, // Hold and release
        "Async": 				[ Param: 3, Size: 1, Default: 0, Enabled: 1, Disabled: 0 ], // Blocked 2 Blocked
        "BleTempAllowTimer": 	[ Param: 4, Size: 4, Default: 0, Min: 0, Max: 2147483647, Value: reverseValue(value) ].with { put('ParamValue', paramValue(value, get('Size'))); it },
        "BleAlwaysAllowed": 	[ Param: 5, Size: 1, Default: 0, Enabled: 1, Disabled: 0 ],
        "AutoLock": 			[ Param: 6, Size: 4, Default: 0, Min: 0, Max: 2147483647, Value: reverseValue(value) ].with { put('ParamValue', paramValue(value, get('Size'))); it },
    ]
}

private getSchlageParamMap(value = null) {
    [
        "CodeLength": 			[ Param: 16, Size: 1, Default: 4, Min: 4, Max: 8, Value: reverseValue(value) ].with { put('ParamValue', paramValue(value, get('Size'))); it },
    ]
}

private getSamsungParamMap(value = null) {
    [
        "PrivacyMode": 			[ Param: 2, Size: 1, Default: 0, Enabled: 1, Disabled: 0 ],
    ]
}

// THIS IS THE END OF THE FILE
